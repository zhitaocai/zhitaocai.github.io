<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Zhitao Cai's Blog]]></title>
  <subtitle><![CDATA[专注成就专业，我只饮菠萝啤]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://caizhitao.com//"/>
  <updated>2016-07-16T00:33:24.000Z</updated>
  <id>http://caizhitao.com//</id>
  
  <author>
    <name><![CDATA[Zhitao Cai]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[如何优雅正确地使用Log]]></title>
    <link href="http://caizhitao.com/2016/05/17/android-use-log-gracefully-and-correctly/"/>
    <id>http://caizhitao.com/2016/05/17/android-use-log-gracefully-and-correctly/</id>
    <published>2016-05-17T00:15:45.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/Momentum/201605170820.jpg" alt=""></p>
<p>本文详细描述了如何采用优雅的姿势并且正确地使用log<br><a id="more"></a></p>
<h1 id="原生的Android_Log使用">原生的Android Log使用</h1><p>像下面这样子的Log，大家都会用<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Log</span>.<span class="literal">i</span>(<span class="string">"test"</span>, <span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">Log</span>.<span class="literal">i</span>(<span class="string">"test"</span>, <span class="string">"hello world "</span> + 1);</span><br><span class="line"><span class="keyword">Log</span>.<span class="literal">i</span>(<span class="string">"test"</span>, <span class="string">"hello world "</span>, new Exception(<span class="string">"test"</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="原生Android_Log的语句不够优雅">原生Android Log的语句不够优雅</h2><p>使用原生Android Log过程中，难免会发现上面的原生Log，用多了，会感觉用得很累，就比如这样子的Log:</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long startTime = System.currentTimeMillis<span class="params">()</span>;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">long endTime = System.currentTimeMillis<span class="params">()</span>;</span><br><span class="line">Log.i<span class="params">(<span class="string">"test"</span>, <span class="string">"Strart Time: "</span> + startTime + <span class="string">"\nEnd Time: "</span> + endTime + <span class="string">"\nTotal Time: "</span> + <span class="params">(endTime - startTime)</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这种log，先不说写的时候多麻烦，单纯看上去就觉得很累，必须要看完整句才大概知道这个Log的含义，<strong>因为一句话被拆分了，中间穿插着不同的参数</strong>，自然而然，为了优雅，大家都可能会想到用<code>String.format()</code>方法来进行优雅一点的输出：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long startTime = System.currentTimeMillis<span class="params">()</span>;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">long endTime = System.currentTimeMillis<span class="params">()</span>;</span><br><span class="line">Log.i<span class="params">(<span class="string">"test"</span>, String.format<span class="params">(<span class="string">"Strart Time: %d\nEndTime: %d\nTotalTime: %d"</span>, startTime, endTime, endTime - startTime)</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="原生的Android_Log并不能很好地输出详细的信息">原生的Android Log并不能很好地输出详细的信息</h2><p>使用原生的Android Log，除非是输出异常的Log，否则是不会详细显示Log的调用信息的，简单来说，我要知道某句正常的Log是在哪里被调用的（比如你接手别人的项目的时候，输出一大堆不知道写在哪里的Log），那么原生的AndroidLog是不支持的，那么我们就要在自己动手一下</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出log的详细调用信息</span></span><br><span class="line">try &#123;</span><br><span class="line">    StackTraceElement[] elements = Thread.currentThread<span class="params">()</span>.getStackTrace<span class="params">()</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(elements.length &gt; <span class="number">5</span>)</span> &#123;</span><br><span class="line">        StackTraceElement element = elements[<span class="number">5</span>];</span><br><span class="line">        String txt = String.format<span class="params">(<span class="string">"FileName:[ %s ] Method:( %s )  Line:( %d )"</span>, element.getFileName<span class="params">()</span>, element.getMethodName<span class="params">()</span>, element.getLineNumber<span class="params">()</span>)</span>;</span><br><span class="line">        Log.i<span class="params">(tag, txt)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch <span class="params">(Throwable e)</span> &#123;</span><br><span class="line">    e.printStackTrace<span class="params">()</span>;</span><br><span class="line">&lt;F11&gt;&lt;F11&gt;&lt;F11&gt;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="封装自己的Log">封装自己的Log</h1><p>基于上面点，我这边自己动手封装一个DLog，概览如下(具体代码请点击<a href="https://github.com/zhitaocai/DLog" target="_blank" rel="external">这里</a>)：</p>
<p><img src="/img/android/log/DLogPreview.png" alt=""></p>
<h1 id="优雅地控制Log输出">优雅地控制Log输出</h1><p>实际项目开发中，我们当然是希望调试的Log在我们开发测试的时候才进行输出，在发布的版本中不进行输出</p>
<p>为什么?</p>
<ol>
<li>如果你的调试Log在发布版本中也存在，那么apk的体积肯定是变大的</li>
<li>如果你的调试Log在发布版本中也存在，那么apk被心怀恶意的人反编译破解的时候，Log的输出就是很好的切入点，能极大地帮助他们理解你的代码</li>
</ol>
<p><strong>总结下来，我们需要的就是一个开关，在我们开发测试的时候，开启Log，在我们发布的时候，关闭Log</strong></p>
<h2 id="使用BuildConfig来控制Log输出">使用BuildConfig来控制Log输出</h2><p>Setp 1: 配置项目Module的build.gradle</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    debug &#123;</span><br><span class="line">        buildConfigField <span class="string">"boolean"</span>, <span class="string">"ISDEBUG"</span>, <span class="string">"true"</span></span><br><span class="line">    &#125;</span><br><span class="line">    release &#123;</span><br><span class="line">        buildConfigField <span class="string">"boolean"</span>, <span class="string">"ISDEBUG"</span>, <span class="string">"false"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Setp 2: 在java代码中如下使用即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BuildConfig.ISDEBUG) &#123;</span><br><span class="line">    DLog.i(<span class="string">"test"</span>, <span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构建release版本，BuildConfig中的ISDEBUG参数就会是false，那么if就永远跑不进去，那么就不会将Log的代码打包到apk中，同理，构建debug版本时，则会输出log</strong></p>
<h2 id="使用Proguard来控制Log输出">使用Proguard来控制Log输出</h2><p>Setp 1: 将自己使用的封装Log类写入到混淆配置(我这里为proguard-rules.pro)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 删除代码中DLog相关的代码</span><br><span class="line">-assumenosideeffects <span class="class"><span class="keyword">class</span> <span class="title">io</span>.<span class="title">github</span>.<span class="title">zhitaocai</span>.<span class="title">dlog</span>.<span class="title">DLog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">e</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ti</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">te</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">td</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tw</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tv</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Setp 2: 开启混淆优化：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled <span class="keyword">true</span>      <span class="comment">// 开启混淆</span></span><br><span class="line">        signingConfig signingConfigs.release</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意是用proguard-android-optimize.txt而不是proguard-android.txt</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Setp 3: java代码中使用的Log如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLog.i(<span class="string">"test"</span>, <span class="string">"test"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>解释说明:</strong></p>
<blockquote>
<p><code>-assumenosideeffects class_specification:</code> Specifies methods that don’t have any side effects (other than maybe returning a value). In the optimization step, ProGuard will then remove calls to such methods, if it can determine that the return values aren’t used. ProGuard will analyze your program code to find such methods automatically. It will not analyze library code, for which this option can therefore be useful. For example, you could specify the method System.currentTimeMillis(), so that any idle calls to it will be removed. With some care, you can also use the option to remove logging code. Note that ProGuard applies the option to the entire hierarchy of the specified methods. Only applicable when optimizing. In general, making assumptions can be dangerous; you can easily break the processed code. Only use this option if you know what you’re doing!</p>
</blockquote>
<ol>
<li><code>assumenosideeffects</code> ： 可以理解为假设某个东西无效，那么混淆（具体为优化阶段）之后就会将这里面假定无效的类移除，从而达到不输出Log的效果</li>
<li>正如说明，要令assumenosideeffects生效，就需要开启混淆 </li>
<li>正如说明，要令assumenosideeffects生效，就需要开启混淆中的优化选项，而默认的proguard-android.txt是不会开启优化选项的 <img src="/img/android/log/proguard-android-txt-part.png" alt=""> 并且，从上面 proguard-android.txt 部分内容截图中，我们可以知道，如果我们需要开启混淆的话，那么是建议我们采用<strong>proguard-android-optimize.txt</strong>，那么就可以解释为什么我们Setp 2需要采用 <code>proguard-android-optimize.txt</code> 作为Android的默认混淆配置了</li>
</ol>
<h2 id="比较">比较</h2><h3 id="测试代码">测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DOWNLOAD_TAG = <span class="string">"download_"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 正常的Android Log 封装使用</span></span><br><span class="line">		Log.i(<span class="string">"aaaaa"</span>, <span class="string">"=======华丽分割线1======="</span>);</span><br><span class="line">		DLog.i(<span class="string">"test"</span>, <span class="string">"下载测试: 1"</span>);</span><br><span class="line">		DLog.d(<span class="string">"test"</span>, <span class="string">"下载测试: "</span> + <span class="number">2</span>);</span><br><span class="line">		DLog.w(<span class="string">"test"</span>, <span class="string">"下载测试: %d"</span>, <span class="number">3</span>);</span><br><span class="line">		DLog.e(<span class="string">"test"</span>, <span class="keyword">new</span> Exception(<span class="string">"测试的Exception"</span>), <span class="string">"下载测试: 4"</span>);</span><br><span class="line">		DLog.v(<span class="string">"test"</span>, <span class="keyword">new</span> Exception(<span class="string">"测试的Exception"</span>), <span class="string">"下载测试: %d"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">		Log.i(<span class="string">"aaaaa"</span>, <span class="string">"=======华丽分割线2======="</span>);</span><br><span class="line">		<span class="comment">// 支持指定前缀tag（方便给tag分类）以及可以指定具体调用类的Log方式</span></span><br><span class="line">		DLog.ti(DOWNLOAD_TAG, <span class="keyword">this</span>, <span class="string">"下载测试 1"</span>);</span><br><span class="line">		DLog.td(DOWNLOAD_TAG, <span class="keyword">this</span>, <span class="string">"下载测试 "</span> + <span class="number">2</span>);</span><br><span class="line">		DLog.tw(DOWNLOAD_TAG, <span class="keyword">this</span>, <span class="string">"下载测试 %d"</span>, <span class="number">3</span>);</span><br><span class="line">		DLog.te(DOWNLOAD_TAG, <span class="keyword">this</span>, <span class="keyword">new</span> Exception(<span class="string">"测试的Exception"</span>), <span class="string">"下载测试 4"</span>);</span><br><span class="line">		DLog.tv(DOWNLOAD_TAG, <span class="keyword">this</span>, <span class="keyword">new</span> Exception(<span class="string">"测试的Exception"</span>), <span class="string">"下载测试 %d"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">		Log.i(<span class="string">"aaaaa"</span>, <span class="string">"=======采用Proguard控制Log输出======="</span>);</span><br><span class="line">		proguardLogTest();</span><br><span class="line"></span><br><span class="line">		Log.i(<span class="string">"aaaaa"</span>, <span class="string">"=======采用BuildConfig控制Log输出======="</span>);</span><br><span class="line">		BuildConfigLogTest();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">proguardLogTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 测试1: log输出中使用方法</span></span><br><span class="line">		Log.i(<span class="string">"aaaaa"</span>, <span class="string">"=======proguard 1======="</span>);</span><br><span class="line">		<span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">		DLog.i(<span class="string">"network"</span>, <span class="string">"加密byte数组: %s"</span>, formatByte2String(input));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 测试2: log输出中使用方法，并且该方法中和其他存在关联</span></span><br><span class="line">		Log.i(<span class="string">"aaaaa"</span>, <span class="string">"=======proguard 2======="</span>);</span><br><span class="line">		DLog.ti(DOWNLOAD_TAG, <span class="keyword">this</span>, <span class="string">"下载测试 %d"</span>, incrementI());</span><br><span class="line">		DLog.ti(DOWNLOAD_TAG, <span class="keyword">this</span>, <span class="string">"下载测试 %d"</span>, incrementI());</span><br><span class="line">		DLog.ti(DOWNLOAD_TAG, <span class="keyword">this</span>, <span class="string">"下载测试 %d"</span>, incrementI());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 测试3: 外部先构建好一个对象，然后输出该对象的toString</span></span><br><span class="line">		Log.i(<span class="string">"aaaaa"</span>, <span class="string">"=======proguard 3======="</span>);</span><br><span class="line">		TestModel testModel = <span class="keyword">new</span> TestModel(<span class="string">"下载测试 1000"</span>);</span><br><span class="line">		DLog.ti(DOWNLOAD_TAG, <span class="keyword">this</span>, testModel.toString());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildConfigLogTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 测试1: log输出中使用方法</span></span><br><span class="line">		Log.i(<span class="string">"aaaaa"</span>, <span class="string">"=======proguard 1======="</span>);</span><br><span class="line">		<span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">		<span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">			DLog.i(<span class="string">"network"</span>, <span class="string">"加密byte数组: %s"</span>, formatByte2String(input));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 测试2: log输出中使用方法，并且该方法中和其他存在关联</span></span><br><span class="line">		Log.i(<span class="string">"aaaaa"</span>, <span class="string">"=======proguard 2======="</span>);</span><br><span class="line">		<span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">			DLog.ti(DOWNLOAD_TAG, <span class="keyword">this</span>, <span class="string">"下载测试 %d"</span>, incrementI());</span><br><span class="line">			DLog.ti(DOWNLOAD_TAG, <span class="keyword">this</span>, <span class="string">"下载测试 %d"</span>, incrementI());</span><br><span class="line">			DLog.ti(DOWNLOAD_TAG, <span class="keyword">this</span>, <span class="string">"下载测试 %d"</span>, incrementI());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 测试3: 外部先构建好一个对象，然后输出该对象的toString</span></span><br><span class="line">		Log.i(<span class="string">"aaaaa"</span>, <span class="string">"=======proguard 3======="</span>);</span><br><span class="line">		TestModel testModel = <span class="keyword">new</span> TestModel(<span class="string">"下载测试 1000"</span>);</span><br><span class="line">		<span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">			DLog.ti(DOWNLOAD_TAG, <span class="keyword">this</span>, testModel.toString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 假设这个方法为将byte数组加密成Base64(对应于实际场合中的，和服务器联调测试时，解密网络请求中返回的数据时用)</span><br><span class="line">	 *</span><br><span class="line">	 * <span class="doctag">@return</span> encodeString</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">formatByte2String</span><span class="params">(<span class="keyword">byte</span>[] input)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Base64.encodeToString(input, Base64.NO_WRAP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">protected</span> String mTest;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">TestModel</span><span class="params">(String test)</span> </span>&#123;</span><br><span class="line">			mTest = test;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"TestModel &#123;\n"</span>);</span><br><span class="line">			sb.append(<span class="string">"  mTest=\""</span>).append(mTest).append(<span class="string">'\"'</span>).append(<span class="string">"\n"</span>);</span><br><span class="line">			sb.append(<span class="string">'&#125;'</span>);</span><br><span class="line">			<span class="keyword">return</span> sb.toString();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反编译结果">反编译结果</h3><p><img src="/img/android/log/BuildConfig_vs_Proguard.png" alt=""></p>
<h3 id="结论">结论</h3><ul>
<li>BuildConfig<ul>
<li>Log输出时，如果DLog.i中的传入参数是一些方法的返回值或者自定义对象的某些方法诸如此类的依赖值，那么用BuildConfig这种方法时，是连这个方法或者自定义对象的方法都不会执行，完成优化掉，减少apk体积同时也优化运行速度（因为不用在调用这些方法）</li>
<li>缺陷就是使用的时候比较麻烦，不断写<code>if(BuildConfig.ISDEBUG) {...}</code>，比较麻烦</li>
</ul>
</li>
<li>Proguard<ul>
<li>Log输出时，如果DLog.i中的传入参数是一些方法的返回值或者自定义对象的某些方法诸如此类的依赖值，那么用Proguard这种方法时，仅仅是会不输出Log，但是，Log传入参数所依赖的方法或者自定义对象的方法是会执行的，不能很好优化掉，并且你还要确定，这部分还继续被执行的代码是否可以真的继续执行</li>
<li>其实采用这种方法还是有一点弊端的样子，在 <code>proguard-android-optimize.txt</code> 文件中存在一段话: <img src="/img/android/log/proguard-android-optimize-txt-part.png" alt=""> <strong>混淆时，开启优化选项存在风险</strong></li>
<li>优点：可以直接调用DLog.i()进行打log，而不用像BuildConfig那样子，每次打Log之前都需要if一下</li>
</ul>
</li>
</ul>
<p><strong>Any Way, 最终结论是建议大家使用BuildConfig的方法控制Log开关，使用Proguard的方法来控制Log的话需要慎用</strong></p>
<h1 id="参考文献">参考文献</h1><ul>
<li><a href="http://proguard.sourceforge.net/" target="_blank" rel="external">http://proguard.sourceforge.net/</a></li>
<li><a href="http://www.jianshu.com/p/60e82aafcfd0" target="_blank" rel="external">http://www.jianshu.com/p/60e82aafcfd0</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/Momentum/201605170820.jpg" alt=""></p>
<p>本文详细描述了如何采用优雅的姿势并且正确地使用log<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://caizhitao.com/tags/Android/"/>
    
      <category term="Android Develop" scheme="http://caizhitao.com/categories/Android-Develop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android订阅推荐]]></title>
    <link href="http://caizhitao.com/2016/02/29/rss-share/"/>
    <id>http://caizhitao.com/2016/02/29/rss-share/</id>
    <published>2016-02-29T12:32:39.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/Momentum/201602292033.jpg" alt=""></p>
<p>4年一度才有的2月29日，不发布点内容，真对不起这个特殊的日子，这次和大家分享一下我平时自己订阅和关注的微信号，blog，weekly</p>
<a id="more"></a>
<h1 id="android-weekly"><a href="http://androidweekly.net/" target="_blank" rel="external">android-weekly</a></h1><p>应该很多人都有订阅这个了，每周一保，内容绝对前沿，收录的文章基本是英文，如果觉得阅读有困难，也可以同时订阅有<a href="http://wiki.jikexueyuan.com/project/android-weekly/" target="_blank" rel="external">极客学院翻译的android-weekly</a>，不过也就翻译了目录，内容并没有翻译，但是也方便我们十分快捷了解本周的一些新鲜事</p>
<h1 id="Android_开发技术周报"><a href="http://www.androidweekly.cn/" target="_blank" rel="external">Android 开发技术周报</a></h1><p>相比起上面的android-weekly，这份是国人维护的，内容相对比较实用，个人感觉这份周报比起android-weekly更实用</p>
<h1 id="腾讯Bugly"><a href="http://bugly.qq.com/bbs/portal.php" target="_blank" rel="external">腾讯Bugly</a></h1><p><strong>微信号：weixinBugly</strong> 腾讯出品，专注android ios领域的各种疑难杂症，深度分析等等等内容</p>
<h1 id="美团技术博客"><a href="http://tech.meituan.com/" target="_blank" rel="external">美团技术博客</a></h1><p><strong>微信号：meituantech</strong> 经常介绍美团目前在已经在使用的技术的总结，除了Android还有其他端的分享，妥妥的干货，更新频率相比起其他几个，没有那么快，但是完全不影响其质量</p>
<h1 id="AndroidDeveloper">AndroidDeveloper</h1><p><strong>微信号：googdev</strong> 大神stormzhang搞起来的，从16年开始，更新频率很高，基本每天一篇，都是各种干货，然后也是趁着今天<strong>2016-02-29</strong>，发布了一篇《Android学习资料的收录》，内容确实很多，好吧，我承认，每天看这个订阅号都要花很多时间了</p>
<h1 id="持续更新">持续更新</h1><p>精力有限，目前我个人主要关注和订阅的就上面几个源，相信大家平时也有关注很多的优秀内容，欢迎大家齐齐分享</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/Momentum/201602292033.jpg" alt=""></p>
<p>4年一度才有的2月29日，不发布点内容，真对不起这个特殊的日子，这次和大家分享一下我平时自己订阅和关注的微信号，blog，weekly</p>]]>
    
    </summary>
    
      <category term="rss" scheme="http://caizhitao.com/tags/rss/"/>
    
      <category term="Android Develop" scheme="http://caizhitao.com/categories/Android-Develop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在多个Gradle脚本中传递变量]]></title>
    <link href="http://caizhitao.com/2016/02/22/pass-variables-via-diff-gradlesrcipt/"/>
    <id>http://caizhitao.com/2016/02/22/pass-variables-via-diff-gradlesrcipt/</id>
    <published>2016-02-22T08:07:44.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/Momentum/201602221815.jpg" alt=""></p>
<p>实际项目中，我们可能在发布的时候，需要调用到很多个项目的gradle脚本，用于分别执行每个项目的一些打包工作，这个时候就涉及到gradle多脚本的相互调用了，本次和大家一起探讨</p>
<ul>
<li>多个gradle脚本相互调用task的方法</li>
<li>多个gradle脚本中共享Property</li>
</ul>
<a id="more"></a>
<h1 id="多个gradle脚本相互调用的方法">多个gradle脚本相互调用的方法</h1><h2 id="通过apply_from">通过apply from</h2><p>利用<code>apply from</code>，在<code>build.gradle</code>中引入其他Gradle脚本</p>
<p><code>build.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="keyword">from</span>: <span class="string">'other.gradle'</span></span><br></pre></td></tr></table></figure>
<p><code>other.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> show &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">"123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过GradleBuild_Type">通过GradleBuild Type</h2><p><code>build.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> showAll(type: GradleBuild) &#123;</span><br><span class="line">    buildFile = <span class="string">'other.gradle'</span></span><br><span class="line">    tasks = [<span class="string">'show'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>other.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> show &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">"123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在多个gradle脚本中共享Property">在多个gradle脚本中共享Property</h1><p>关于Property的分类，可以先看看<a href="http://caizhitao.com/2016/02/20/gradle-properties/">Gradle Property使用详解</a></p>
<h2 id="共享System_Property">共享System Property</h2><p>默认都能共享</p>
<h2 id="共享Gradle_Property">共享Gradle Property</h2><p>在<code>build.gradle</code>中通过<code>GradleBuild</code>方法调用其他脚本的时候，指定<a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.GradleBuild.html" target="_blank" rel="external">GradleBuild</a> 的<a href="https://docs.gradle.org/current/javadoc/org/gradle/StartParameter.html" target="_blank" rel="external">StartParameter</a> 参数为本project传入的Properties，那么外部脚本即可共享本project的Gradle Property</p>
<p><code>build.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> showAll(type: GradleBuild) &#123;</span><br><span class="line">    buildFile = <span class="string">'other.gradle'</span></span><br><span class="line">    tasks = [<span class="string">'show'</span>]</span><br><span class="line">    <span class="comment">// 指定调用外部gradle的脚本的时候，该外部脚本采用的Properties参数为本项目所采用的</span></span><br><span class="line">    startParameter.projectProperties = <span class="keyword">project</span>.getGradle().getStartParameter().getProjectProperties()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// or </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// startParameter.projectProperties = gradle.startParameter.projectProperties</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>other.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> show &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> var1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行命令</span></span><br><span class="line">gradle -q showAll -Pvar1=test </span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 </span></span><br><span class="line">test</span><br></pre></td></tr></table></figure>
<h2 id="共享自定义的Property">共享自定义的Property</h2><p>利用<code>apply from</code>，在<code>build.gradle</code>中引入其他Gradle脚本，然后通过自定义的Property即可跨脚本传递变量或者方法，详细做法可以参考<a href="http://paweloczadly.github.io/dev/2014/07/03/gradle-how-to-use-variables-and-methods-from-another-gradle-file" target="_blank" rel="external">这里</a> </p>
<p><em>ps：本来想着翻译转换一下思路，但是改着改着，到最后发现作者写得太好了，怎么改都都表达不出原文的原汁原味，于是就直接贴原文链接出来了</em></p>
<h1 id="选择与总结">选择与总结</h1><ol>
<li><code>共享System Property方式</code>：一般用于指定一些环境变量</li>
<li><code>共享Gradle Property方式</code>：如果其他脚本中所有的task已经写好了逻辑了，就差一个开关之类的控制一些简单的逻辑，那么不妨采用这种方法</li>
<li><code>共享自定义的Property方式</code>：可以很方便地和主脚本(<code>build.gradle</code>)进行交互，但是如果主脚本和其他外部脚本同时引入同一个<code>plugin</code>，那么在执行task（比如都使用了java插件，两个脚本中分别有一个任务都是依赖于<code>jar</code>）的时候，就可能会出现问题</li>
</ol>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.GradleBuild.html" target="_blank" rel="external">GradleBuild官方文档描述</a></li>
<li><a href="https://docs.gradle.org/current/javadoc/org/gradle/StartParameter.html" target="_blank" rel="external">StartParameter官方文档描述</a> </li>
<li><a href="https://www.coveros.com/passing-p-parameters-from-one-gradle-script-to-another/" target="_blank" rel="external">https://www.coveros.com/passing-p-parameters-from-one-gradle-script-to-another/</a></li>
<li><a href="http://paweloczadly.github.io/dev/2014/07/03/gradle-how-to-use-variables-and-methods-from-another-gradle-file" target="_blank" rel="external">http://paweloczadly.github.io/dev/2014/07/03/gradle-how-to-use-variables-and-methods-from-another-gradle-file</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/Momentum/201602221815.jpg" alt=""></p>
<p>实际项目中，我们可能在发布的时候，需要调用到很多个项目的gradle脚本，用于分别执行每个项目的一些打包工作，这个时候就涉及到gradle多脚本的相互调用了，本次和大家一起探讨</p>
<ul>
<li>多个gradle脚本相互调用task的方法</li>
<li>多个gradle脚本中共享Property</li>
</ul>]]>
    
    </summary>
    
      <category term="Gradle" scheme="http://caizhitao.com/tags/Gradle/"/>
    
      <category term="Gradle" scheme="http://caizhitao.com/categories/Gradle/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gradle Property 使用详解]]></title>
    <link href="http://caizhitao.com/2016/02/20/gradle-properties/"/>
    <id>http://caizhitao.com/2016/02/20/gradle-properties/</id>
    <published>2016-02-20T05:31:09.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/Momentum/201602201404.jpg" alt=""></p>
<p>Gradle支持很多种方式去设置Property，方式太多了，我们有必要了解一下每种方式的使用</p>
<a id="more"></a>
<h1 id="Property_分类">Property 分类</h1><p>Property 可以分为3类：</p>
<ul>
<li>Gradle Property </li>
<li>System Property </li>
<li>自定义Property </li>
</ul>
<h1 id="Gradle_Property">Gradle Property</h1><h2 id="通过命令行定义">通过命令行定义</h2><p>通过命令行定义的Gradle Property，格式必须为 <code>-Pxxx</code>，其中<code>xxx</code>为对应的Property名字</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -q showGradleProperty -PmyProperty=myPropertyFromGradleCMD</span><br></pre></td></tr></table></figure>
<p><code>build.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> showGradleProperty &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> myProperty </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过gradle-properties定义">通过gradle.properties定义</h2><p><code>gradle.properties</code>:</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">myProperty</span>=<span class="string">myPropertyFromGradleProperties</span></span><br></pre></td></tr></table></figure>
<p><code>build.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> showGradleProperty &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> myProperty </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="System_Property">System Property</h1><h2 id="通过命令行定义-1">通过命令行定义</h2><p>我们可以通过-D参数定义JVM的系统参数，格式必须为 <code>-Dorg.gradle.project.xxx</code>，其中<code>xxx</code>为对应的Property名字</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -q showSystemProperty -Dorg.gradle.<span class="keyword">project</span>.myProperty=myPropertyFromSystemPropertyCMD</span><br></pre></td></tr></table></figure>
<p><code>build.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> showSystemProperty &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> System.properties[<span class="string">'myProperty'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过gradle-properties定义-1">通过gradle.properties定义</h2><p>通过gradle.properties定义的SystemProperty，格式必须为 <code>systemProp.xxx</code>，其中<code>xxx</code>为对应的Property名字</p>
<p><code>gradle.properties</code>：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemProp.myPropert</span>=<span class="string">myPropertyFromGradlePropertiesSystemProp</span></span><br></pre></td></tr></table></figure>
<p><code>build.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> showSystemProperty &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> System.properties[<span class="string">'myProperty'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过系统环境变量设置">通过系统环境变量设置</h2><p>在环境变量中定义的SystemProperty，格式必须为 <code>ORG_GRADLE_PROJECT_xxx</code>，其中<code>xx</code>为对应的Property名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ORG_GRADLE_PROJECT_myProperty=myPropertyFromEnv</span><br></pre></td></tr></table></figure>
<p><code>build.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> showSystemPropertyFromEnv &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> myProperty </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义Property">自定义Property</h1><h2 id="通过ext定义">通过ext定义</h2><p><code>build.gradle</code>:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ext.myProperty = <span class="string">"myProperty from ext"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ext &#123;</span></span><br><span class="line"><span class="comment">//     myProperty = "myProperty from ext"</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> showProperty &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> myProperty </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优先级">优先级</h1><p>从Property的传入方式，我们大致分为</p>
<ul>
<li><code>命令行传入Property</code></li>
<li><code>在gradle.properties传入Property</code></li>
<li><code>在系统环境变量中传入Property</code></li>
</ul>
<p>如果在多个地方设置了同一个Property，那么优先采用次序依次为：</p>
<p><code>命令行传入Property</code> &gt; <code>在gradle.properties传入Property</code> &gt; <code>在系统环境变量中传入Property</code></p>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="https://docs.gradle.org/current/userguide/build_environment.html" target="_blank" rel="external">https://docs.gradle.org/current/userguide/build_environment.html</a></li>
<li><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-5.html" target="_blank" rel="external">http://www.cnblogs.com/davenkin/p/gradle-learning-5.html</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/Momentum/201602201404.jpg" alt=""></p>
<p>Gradle支持很多种方式去设置Property，方式太多了，我们有必要了解一下每种方式的使用</p>]]>
    
    </summary>
    
      <category term="Gradle" scheme="http://caizhitao.com/tags/Gradle/"/>
    
      <category term="Gradle" scheme="http://caizhitao.com/categories/Gradle/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决小米MIUI系统上后台应用没法弹Toast的问题]]></title>
    <link href="http://caizhitao.com/2016/02/09/android-toast-compat/"/>
    <id>http://caizhitao.com/2016/02/09/android-toast-compat/</id>
    <published>2016-02-08T23:42:13.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/Momentum/201602090742.jpg" alt=""></p>
<p>早~~，大年初二，一大早就被喉咙痛痛醒（夜晚睡觉之前不要饮太多雪碧），实在受不了，就起床了，想起前段时间在小米系统上遇到的一个诡异问题，于是趁这个机会码一下</p>
<a id="more"></a>
<h2 id="问题">问题</h2><p>某一天发现在小米的MIUI系统上，一个好好的Toast总是不能弹出来，写法是没有问题的，直到发现log中出现一个<code>invisible to user</code>的输出，几经google，百度，解决方案没找到，倒是在 <a href="http://www.miui.com/thread-2628717-1-1.html" target="_blank" rel="external">小米开发者论坛帖子</a>中找到发现相同问题的同学们T_T<br><img src="/img/MIUI/toast-problem.png" alt=""></p>
<p>问题明确了：<strong>后台应用在小米MIUI系统（没有仔细测试每个版本，应该是自某个版本开始的，大概测试的时候，低版本miui还是正常运行，高版本的就不能）上没有办法弹出Toast。</strong></p>
<h2 id="解决">解决</h2><p>经过一番看源码和在某一篇<a href="http://www.cnblogs.com/net168/p/4058193.html" target="_blank" rel="external">关于Toast源码分析的博文</a>中了解到</p>
<p>Toast的弹出流程：</p>
<ol>
<li>通过<code>new Toast(Context context)</code>或者<code>makeText(...)</code>方法实例化Toast对象</li>
<li>调用<code>show()</code>方法之后，实例会加入到一个TN变量(AIDL)的服务队列中，而这个队列由系统维护</li>
<li>TN控制Toast的显示和消息</li>
</ol>
<p>于是就好猜测了，MIUI上可能是出于<strong>“绿化”</strong>的考虑，在维护Toast队列的时候，Toast只能在自己的进程运行在顶端的时候才能弹出来，否则就<strong>“invisible to user”</strong>.</p>
<p>那么尝试性的解决方案就有了：<strong>我们自己参照Toast的源码，重写一份，最后show的时候，不进入TN维护的队列，我们自己用Handler+Queue来维护Toast的消息队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.zhitaocai.toastcompat.toastcompat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.TargetApi;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.Configuration;</span><br><span class="line"><span class="keyword">import</span> android.graphics.PixelFormat;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.view.Gravity;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManager;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.github.zhitaocai.toastcompat.util.DisplayUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@author</span> zhitao</span><br><span class="line"> * <span class="doctag">@since</span> 2016-01-21 14:33</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MIUIToast</span> <span class="keyword">implements</span> <span class="title">IToast</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Handler mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 维护toast的队列</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;MIUIToast&gt; mQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;MIUIToast&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 原子操作：判断当前是否在读取&#123;<span class="doctag">@linkplain</span> #mQueue 队列&#125;来显示toast</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> AtomicInteger mAtomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WindowManager mWindowManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mDurationMillis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View mView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WindowManager.LayoutParams mParams;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IToast <span class="title">makeText</span><span class="params">(Context context, String text, <span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MIUIToast(context).setText(text).setDuration(duration)</span><br><span class="line">                .setGravity(Gravity.BOTTOM, <span class="number">0</span>, DisplayUtil.dip2px(context, <span class="number">64</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MIUIToast</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mContext = context;</span><br><span class="line">        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        mParams = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">        mParams.height = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">        mParams.width = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">        mParams.format = PixelFormat.TRANSLUCENT;</span><br><span class="line">        mParams.windowAnimations = android.R.style.Animation_Toast;</span><br><span class="line">        mParams.type = WindowManager.LayoutParams.TYPE_TOAST;</span><br><span class="line">        mParams.setTitle(<span class="string">"Toast"</span>);</span><br><span class="line">        mParams.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |</span><br><span class="line">                        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;</span><br><span class="line">        <span class="comment">// 默认小米Toast在下方居中</span></span><br><span class="line">        mParams.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Set the location at which the notification should appear on the screen.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> gravity</span><br><span class="line">     * <span class="doctag">@param</span> xOffset</span><br><span class="line">     * <span class="doctag">@param</span> yOffset</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@TargetApi</span>(Build.VERSION_CODES.JELLY_BEAN_MR1)</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IToast <span class="title">setGravity</span><span class="params">(<span class="keyword">int</span> gravity, <span class="keyword">int</span> xOffset, <span class="keyword">int</span> yOffset)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can resolve the Gravity here by using the Locale for getting</span></span><br><span class="line">        <span class="comment">// the layout direction</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> finalGravity;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Configuration config = mView.getContext().getResources().getConfiguration();</span><br><span class="line">            finalGravity = Gravity.getAbsoluteGravity(gravity, config.getLayoutDirection());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            finalGravity = gravity;</span><br><span class="line">        &#125;</span><br><span class="line">        mParams.gravity = finalGravity;</span><br><span class="line">        <span class="keyword">if</span> ((finalGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;</span><br><span class="line">            mParams.horizontalWeight = <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((finalGravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;</span><br><span class="line">            mParams.verticalWeight = <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mParams.y = yOffset;</span><br><span class="line">        mParams.x = xOffset;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IToast <span class="title">setDuration</span><span class="params">(<span class="keyword">long</span> durationMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (durationMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mDurationMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (durationMillis == Toast.LENGTH_SHORT) &#123;</span><br><span class="line">            mDurationMillis = <span class="number">2000</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (durationMillis == Toast.LENGTH_LONG) &#123;</span><br><span class="line">            mDurationMillis = <span class="number">3500</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mDurationMillis = durationMillis;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 不能和&#123;<span class="doctag">@link</span> #setText(String)&#125;一起使用，要么&#123;<span class="doctag">@link</span> #setView(View)&#125; 要么&#123;<span class="doctag">@link</span> #setView(View)&#125;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> view</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IToast <span class="title">setView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        mView = view;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IToast <span class="title">setMargin</span><span class="params">(<span class="keyword">float</span> horizontalMargin, <span class="keyword">float</span> verticalMargin)</span> </span>&#123;</span><br><span class="line">        mParams.horizontalMargin = horizontalMargin;</span><br><span class="line">        mParams.verticalMargin = verticalMargin;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 不能和&#123;<span class="doctag">@link</span> #setView(View)&#125;一起使用，要么&#123;<span class="doctag">@link</span> #setView(View)&#125; 要么&#123;<span class="doctag">@link</span> #setView(View)&#125;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IToast <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟Toast的布局文件 com.android.internal.R.layout.transient_notification</span></span><br><span class="line">        <span class="comment">// 虽然可以手动用java写，但是不同厂商系统，这个布局的设置好像是不同的，因此我们自己获取原生Toast的view进行配置</span></span><br><span class="line"></span><br><span class="line">        View view = Toast.makeText(mContext, text, Toast.LENGTH_SHORT).getView();</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TextView tv = (TextView) view.findViewById(android.R.id.message);</span><br><span class="line">            tv.setText(text);</span><br><span class="line">            setView(view);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 将本次需要显示的toast加入到队列中</span></span><br><span class="line">        mQueue.offer(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 如果队列还没有激活，就激活队列，依次展示队列中的toast</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == mAtomicInteger.get()) &#123;</span><br><span class="line">            mAtomicInteger.incrementAndGet();</span><br><span class="line">            mHandler.post(mActivite);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 如果队列已经处于非激活状态或者队列没有toast了，就表示队列没有toast正在展示了，直接return</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == mAtomicInteger.get() &amp;&amp; mQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 当前显示的toast是否为本次要取消的toast，如果是的话</span></span><br><span class="line">        <span class="comment">// 2.1 先移除之前的队列逻辑</span></span><br><span class="line">        <span class="comment">// 2.2 立即暂停当前显示的toast</span></span><br><span class="line">        <span class="comment">// 2.3 重新激活队列</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.equals(mQueue.peek())) &#123;</span><br><span class="line">            mHandler.removeCallbacks(mActivite);</span><br><span class="line">            mHandler.post(mHide);</span><br><span class="line">            mHandler.post(mActivite);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO</span> 如果一个Toast在队列中的等候展示，当调用了这个toast的取消时，考虑是否应该从对队列中移除，看产品需求吧</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mWindowManager.removeView(mView);</span><br><span class="line">            &#125;</span><br><span class="line">            mWindowManager.addView(mView, mParams);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag"><span class="keyword">note</span></span>: checking parent() just to make sure the view has</span></span><br><span class="line">            <span class="comment">// been added...  i have seen cases where we get here when</span></span><br><span class="line">            <span class="comment">// the view isn't yet added, so let's try not to crash.</span></span><br><span class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mWindowManager.removeView(mView);</span><br><span class="line">                <span class="comment">// 同时从队列中移除这个toast</span></span><br><span class="line">                mQueue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            mView = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">activeQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MIUIToast miuiToast = mQueue.peek();</span><br><span class="line">        <span class="keyword">if</span> (miuiToast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不能从队列中获取到toast的话，那么就表示已经暂时完所有的toast了</span></span><br><span class="line">            <span class="comment">// 这个时候需要标记队列状态为：非激活读取中</span></span><br><span class="line">            mAtomicInteger.decrementAndGet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果还能从队列中获取到toast的话，那么就表示还有toast没有展示</span></span><br><span class="line">            <span class="comment">// 1. 展示队首的toast</span></span><br><span class="line">            <span class="comment">// 2. 设置一定时间后主动采取toast消失措施</span></span><br><span class="line">            <span class="comment">// 3. 设置展示完毕之后再次执行本逻辑，以展示下一个toast</span></span><br><span class="line">            mHandler.post(miuiToast.mShow);</span><br><span class="line">            mHandler.postDelayed(miuiToast.mHide, miuiToast.mDurationMillis);</span><br><span class="line">            mHandler.postDelayed(mActivite, miuiToast.mDurationMillis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mShow = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            handleShow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mHide = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            handleHide();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Runnable mActivite = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            activeQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整源码地址在<a href="https://github.com/zhitaocai/ToastCompat" target="_blank" rel="external">这里</a></p>
<h2 id="后记（2016-02-19）">后记（2016-02-19）</h2><p>今天测试的时候，升级红米2的MIUI系统为 <strong>MIUI 7.0 | 稳定版7.0.6.0 (LHMCNCI)</strong> ，发现使用系统默认的toast，后台应用也能弹出toast了</p>
<p><strong>所以猜测MIUI系统在某个版本区间，才会出现后台应用没法弹出toast的问题</strong></p>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/net168/p/4041763.html" target="_blank" rel="external">Android：谈一谈安卓应用中的Toast情节（基础）</a></li>
<li><a href="http://www.cnblogs.com/net168/p/4058193.html" target="_blank" rel="external">Android：剖析源码，随心所欲控制Toast显示</a></li>
<li><a href="http://www.cnblogs.com/net168/p/4237528.html" target="_blank" rel="external">Android应用系列：仿MIUI的Toast动画效果实现（有图有源码）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/Momentum/201602090742.jpg" alt=""></p>
<p>早~~，大年初二，一大早就被喉咙痛痛醒（夜晚睡觉之前不要饮太多雪碧），实在受不了，就起床了，想起前段时间在小米系统上遇到的一个诡异问题，于是趁这个机会码一下</p>]]>
    
    </summary>
    
      <category term="Android 系统兼容" scheme="http://caizhitao.com/tags/Android-%E7%B3%BB%E7%BB%9F%E5%85%BC%E5%AE%B9/"/>
    
      <category term="Android Develop" scheme="http://caizhitao.com/categories/Android-Develop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Gradle随笔】多任务创建与执行]]></title>
    <link href="http://caizhitao.com/2016/02/07/Groovy-multi-task-execute/"/>
    <id>http://caizhitao.com/2016/02/07/Groovy-multi-task-execute/</id>
    <published>2016-02-07T05:23:32.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/Momentum/201602071323.jpg" alt=""><br>某日在逛stackoverflow的时候遇到一个提问，恰好和我之前遇到的差不多，于是就记下来了：<br><strong>Jörgen Lundberg 提出如何将下面的写法优化缩减</strong><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> cleanCommon(type: GradleBuild) &#123;</span><br><span class="line">  buildFile = <span class="string">'common/build.gradle'</span>  </span><br><span class="line">  tasks = [<span class="string">'clean'</span>]  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> cleanCrawler(type: GradleBuild) &#123;</span><br><span class="line">  buildFile = <span class="string">'crawler/build.gradle'</span></span><br><span class="line">  tasks = [<span class="string">'clean'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> cleanPortlet(type: GradleBuild) &#123;</span><br><span class="line">  buildFile = <span class="string">'portlet/build.gradle'</span></span><br><span class="line">  tasks = [<span class="string">'clean'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> cleanAll(dependsOn: [<span class="string">'cleanCommon'</span>, <span class="string">'cleanCrawler'</span>, <span class="string">'cleanPortlet'</span>]) &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在围观了一众大神的回答之后，我突然觉得我自己的回复算是比较简洁的，因此就记录下来：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> List buildFileList = [<span class="string">'common/build.gradle'</span>, <span class="string">'crawler/build.gradle'</span>, <span class="string">'portlet/build.gradle'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> cleanAll &lt;&lt; &#123;</span><br><span class="line">    buildFileList.<span class="keyword">each</span>() &#123;</span><br><span class="line">        <span class="keyword">def</span> tempTask = tasks.create(name: <span class="string">"execute_$it"</span>, type: GradleBuild)</span><br><span class="line">        tempTask.buildFile=<span class="string">"$it"</span></span><br><span class="line">        tempTask.tasks = [<span class="string">'clean'</span>]</span><br><span class="line">        tempTask.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：刚刚上去看了一下，也看到其他大神在陆续回复，如果大家还继续感兴趣的话，<a href="http://stackoverflow.com/questions/13703218/with-gradle-is-it-possible-to-call-gradlebuild-directly-instead-of-specifying-i" target="_blank" rel="external">点我围观</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/Momentum/201602071323.jpg" alt=""><br>某日在逛stackoverflow的时候遇到一个提问，恰好和我之前遇到的差不多，于是就记下来了：<br><strong>Jörgen Lundberg 提出如何将下面的写法优化缩减</strong><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> cleanCommon(type: GradleBuild) &#123;</span><br><span class="line">  buildFile = <span class="string">'common/build.gradle'</span>  </span><br><span class="line">  tasks = [<span class="string">'clean'</span>]  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> cleanCrawler(type: GradleBuild) &#123;</span><br><span class="line">  buildFile = <span class="string">'crawler/build.gradle'</span></span><br><span class="line">  tasks = [<span class="string">'clean'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> cleanPortlet(type: GradleBuild) &#123;</span><br><span class="line">  buildFile = <span class="string">'portlet/build.gradle'</span></span><br><span class="line">  tasks = [<span class="string">'clean'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> cleanAll(dependsOn: [<span class="string">'cleanCommon'</span>, <span class="string">'cleanCrawler'</span>, <span class="string">'cleanPortlet'</span>]) &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Gradle" scheme="http://caizhitao.com/tags/Gradle/"/>
    
      <category term="Groovy" scheme="http://caizhitao.com/tags/Groovy/"/>
    
      <category term="Gradle" scheme="http://caizhitao.com/categories/Gradle/"/>
    
      <category term="Groovy" scheme="http://caizhitao.com/categories/Gradle/Groovy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ADB常用命令手册]]></title>
    <link href="http://caizhitao.com/2016/01/20/useful-adb-shell/"/>
    <id>http://caizhitao.com/2016/01/20/useful-adb-shell/</id>
    <published>2016-01-20T07:07:05.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>记住一些常用的adb命令，会为我们的工作提供极大的帮助<br><a id="more"></a></p>
<h2 id="基本">基本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">help</span>            // 查看adb帮助</span><br><span class="line">adb start-server    // 开启adb服务</span><br><span class="line">adb <span class="built_in">kill</span>-server     // 关闭adb服务 </span><br><span class="line">adb devices         // 显示连接到计算机的设备</span><br><span class="line"></span><br><span class="line">adb [<span class="operator">-d</span>|<span class="operator">-e</span>|<span class="operator">-s</span> &lt;serialNumber&gt;] &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="operator">-d</span> 发送命令给usb连接的设备</span><br><span class="line">    <span class="operator">-e</span> 发送命令到模拟器设备</span><br><span class="line">    <span class="operator">-s</span> &lt;serialNumber&gt; 发送命令到指定设备</span><br></pre></td></tr></table></figure>
<h2 id="常用">常用</h2><h3 id="清除应用数据">清除应用数据</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> pm <span class="built_in">clear</span> yourpackagename</span><br></pre></td></tr></table></figure>
<h3 id="安装APK">安装APK</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">install</span> &lt;apkfile&gt; //比如：adb <span class="keyword">install</span> baidu.apk</span><br></pre></td></tr></table></figure>
<h3 id="保重新安装apk，留数据和缓存文件">保重新安装apk，留数据和缓存文件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">install</span> -r &lt;apkfile&gt; //比如：adb <span class="keyword">install</span> -r baidu.apk</span><br></pre></td></tr></table></figure>
<h3 id="安装apk到sd卡">安装apk到sd卡</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install <span class="operator">-s</span> &lt;apkfile&gt; // 比如：adb install <span class="operator">-s</span> baidu.apk</span><br></pre></td></tr></table></figure>
<h3 id="卸载APK">卸载APK</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall &lt;<span class="keyword">package</span>&gt; <span class="comment">//比如：adb uninstall com.baidu.search</span></span><br></pre></td></tr></table></figure>
<h3 id="卸载app但保留数据和缓存文件">卸载app但保留数据和缓存文件</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall -k &lt;<span class="keyword">package</span>&gt; <span class="comment">//比如：adb uninstall -k com.baidu.search</span></span><br></pre></td></tr></table></figure>
<h3 id="启动应用">启动应用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -n <span class="tag">&lt;<span class="title">package_name</span>&gt;</span>/.<span class="tag">&lt;<span class="title">activity_class_name</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="查看log">查看log</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">adb</span> logcat</span><br></pre></td></tr></table></figure>
<h3 id="清除log缓存">清除log缓存</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">adb</span> logcat -c</span><br></pre></td></tr></table></figure>
<h3 id="查看bug报告">查看bug报告</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">adb</span> bugreport</span><br></pre></td></tr></table></figure>
<h3 id="重启机器">重启机器</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">adb</span> reboot</span><br></pre></td></tr></table></figure>
<h3 id="重启到bootloader，即刷机模式">重启到bootloader，即刷机模式</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">adb</span> reboot bootloader</span><br></pre></td></tr></table></figure>
<h3 id="重启到recovery，即恢复模式">重启到recovery，即恢复模式</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">adb</span> reboot recovery</span><br></pre></td></tr></table></figure>
<h2 id="查看运行状态">查看运行状态</h2><h3 id="查看设备cpu和内存占用情况">查看设备cpu和内存占用情况</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> top</span><br></pre></td></tr></table></figure>
<h3 id="查看占用内存前6的app">查看占用内存前6的app</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> top -<span class="keyword">m</span> 6</span><br></pre></td></tr></table></figure>
<h3 id="刷新一次内存信息，然后返回">刷新一次内存信息，然后返回</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> top -<span class="keyword">n</span> 1</span><br></pre></td></tr></table></figure>
<h3 id="查看当前内存占用">查看当前内存占用</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /<span class="keyword">proc</span>/meminfo</span><br></pre></td></tr></table></figure>
<h3 id="查看IO内存分区">查看IO内存分区</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /<span class="keyword">proc</span>/iomem</span><br></pre></td></tr></table></figure>
<h3 id="查看后台services信息">查看后台services信息</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="literal">shell</span> <span class="keyword">service</span> list</span><br></pre></td></tr></table></figure>
<h3 id="查询各进程内存使用情况">查询各进程内存使用情况</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> procrank</span><br></pre></td></tr></table></figure>
<h3 id="查看进程列表">查看进程列表</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="literal">shell</span> <span class="built_in">ps</span></span><br></pre></td></tr></table></figure>
<h3 id="杀死一个进程">杀死一个进程</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> <span class="built_in">kill</span> [pid]</span><br></pre></td></tr></table></figure>
<h3 id="查看指定进程状态">查看指定进程状态</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="literal">shell</span> <span class="built_in">ps</span> -x [<span class="constant">P</span>ID]</span><br></pre></td></tr></table></figure>
<h2 id="文件操作">文件操作</h2><h3 id="将system分区重新挂载为可读写分区">将system分区重新挂载为可读写分区</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb remount</span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line"><span class="comment">// 安装系统应用</span></span><br><span class="line"><span class="comment">// adb remount</span></span><br><span class="line"><span class="comment">// adb push <span class="doctag"><span class="keyword">xxx</span>.</span>apk /system/app</span></span><br></pre></td></tr></table></figure>
<h3 id="从本地复制文件到设备">从本地复制文件到设备</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push <span class="tag">&lt;<span class="title">local</span>&gt;</span> <span class="tag">&lt;<span class="title">remote</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="从设备复制文件到本地">从设备复制文件到本地</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull <span class="tag">&lt;<span class="title">remote</span>&gt;</span>  <span class="tag">&lt;<span class="title">local</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="重命名文件">重命名文件</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell <span class="built_in">rename</span> <span class="built_in">path</span>/oldfilename <span class="built_in">path</span>/newfilename</span><br></pre></td></tr></table></figure>
<h3 id="删除system/avi-apk">删除system/avi.apk</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> rm /<span class="keyword">system</span>/avi.apk</span><br></pre></td></tr></table></figure>
<h3 id="删除文件夹及其下面所有文件">删除文件夹及其下面所有文件</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> rm -r &lt;<span class="built_in">folder</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="移动文件">移动文件</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="literal">shell</span> mv <span class="built_in">path</span>/<span class="keyword">file</span> newpath/<span class="keyword">file</span></span><br></pre></td></tr></table></figure>
<h3 id="设置文件权限">设置文件权限</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> chmod <span class="number">777</span> /<span class="keyword">system</span>/fonts/DroidSansFallback.ttf</span><br></pre></td></tr></table></figure>
<h3 id="新建文件夹">新建文件夹</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell <span class="built_in">mkdir</span> <span class="built_in">path</span>/foldelname</span><br></pre></td></tr></table></figure>
<h3 id="查看文件内容">查看文件内容</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">cat</span> &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="获取设备信息">获取设备信息</h2><h3 id="查看Build文件">查看Build文件</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">cat</span> /system/build.<span class="keyword">prop</span></span><br></pre></td></tr></table></figure>
<h3 id="查看wifi密码">查看wifi密码</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">cat</span> /data/misc/wifi/*.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>
<h3 id="获取序列号">获取序列号</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">get</span>-serialno</span><br></pre></td></tr></table></figure>
<h3 id="获取机器MAC地址">获取机器MAC地址</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span>  <span class="keyword">cat</span> /sys/<span class="keyword">class</span>/<span class="keyword">net</span>/wlan0/address</span><br></pre></td></tr></table></figure>
<h3 id="获取CPU序列号">获取CPU序列号</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /<span class="keyword">proc</span>/cpuinfo</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2><h3 id="跑monkey">跑monkey</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -v -<span class="tag">p</span> your<span class="class">.package</span><span class="class">.name</span> <span class="number">500</span></span><br></pre></td></tr></table></figure>
<h2 id="推荐">推荐</h2><ul>
<li><a href="http://www.iteye.com/topic/260042" target="_blank" rel="external">详细一点的介绍，包括使用logcat</a></li>
<li><a href="http://www.cnblogs.com/benhero/p/4287252.html" target="_blank" rel="external">Ubuntu/Mac 解决手机ADB识别问题</a></li>
</ul>
<h3 id="adb_shell_dumpsys">adb shell dumpsys</h3><ul>
<li><a href="https://testerhome.com/topics/1462" target="_blank" rel="external">通过adb dumpsys获取信息</a></li>
<li><a href="http://www.open-open.com/lib/view/open1405061994872.html" target="_blank" rel="external">Android 性能分析工具dumpsys的使用</a></li>
<li><a href="http://blog.iderzheng.com/debug-activity-task-stack-with-adb-shell-dumpsys/" target="_blank" rel="external">使用adb shell dumpsys检测Android的Activity任务栈</a></li>
</ul>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="http://developer.android.com/tools/help/adb.html" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://www.cnblogs.com/jinsdu/archive/2013/02/21/2919874.html" target="_blank" rel="external">http://www.cnblogs.com/jinsdu/archive/2013/02/21/2919874.html</a></li>
<li><a href="http://blog.csdn.net/shuaihj/article/details/8889465" target="_blank" rel="external">http://blog.csdn.net/shuaihj/article/details/8889465</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>记住一些常用的adb命令，会为我们的工作提供极大的帮助<br>]]>
    
    </summary>
    
      <category term="adb" scheme="http://caizhitao.com/tags/adb/"/>
    
      <category term="Android Tools" scheme="http://caizhitao.com/categories/Android-Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Android设备信息】IMSI、ICCID、KI]]></title>
    <link href="http://caizhitao.com/2015/12/01/android-uids-IMSI-ICCID-KI/"/>
    <id>http://caizhitao.com/2015/12/01/android-uids-IMSI-ICCID-KI/</id>
    <published>2015-12-01T02:41:56.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>你应该需要知道的Android设备标识。<br><a id="more"></a></p>
<h1 id="IMSI">IMSI</h1><h2 id="定义">定义</h2><p>IMSI(International Mobile Subscriber Identification Number)：国际移动用户标识码，储存在SIM卡中，可用于区别移动用户的有效信息。其总长度不超过15位，使用0~9的数字</p>
<h2 id="组成">组成</h2><p><code>IMSI = MCC(前3位)+ MNC(接下来2~3位) + MSIN(接下来10位)</code></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MCC(Mobile Country Code)</strong></td>
<td>移动国家码，由国际电信联盟（ITU）在全世界范围内统一分配和管理，唯一识别移动用户所属的国家，共3位，<strong>中国为460</strong></td>
</tr>
<tr>
<td><strong>MNC(Mobile Network Code)</strong></td>
<td>移动网络号码，用于识别用户所归属的通讯网</td>
</tr>
<tr>
<td><strong>MSIN(Mobile Subscriber Identification Number)</strong></td>
<td>移动用户识别号码，用以识别某一个通讯网中的用户</td>
</tr>
</tbody>
</table>
<h2 id="获取方法">获取方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIMSI</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">    <span class="keyword">return</span> telephonyManager.getSubscriberId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展">扩展</h2><h3 id="MCC&amp;&amp;MNC">MCC&amp;&amp;MNC</h3><p>根据MCC和MNC的定义，我们可以在<a href="http://mcclist.com/mobile-network-codes-country-codes.asp" target="_blank" rel="external">这里</a>查询到对应的移动网络说对应的MNC</p>
<table>
<thead>
<tr>
<th>中国移动</th>
<th>中国联通</th>
<th>中国电信</th>
<th>中国铁通</th>
</tr>
</thead>
<tbody>
<tr>
<td>46000</td>
<td>46001</td>
<td>46003(CDMA)</td>
<td>46020(GSM-R)</td>
</tr>
<tr>
<td>46002</td>
<td>46006</td>
<td>46005(CDMA)</td>
<td></td>
</tr>
<tr>
<td>46007</td>
<td></td>
<td>46011(4G)</td>
</tr>
</tbody>
</table>
<h3 id="处理两个IMSI">处理两个IMSI</h3><p>在大天朝，你不能仅仅看上面的定义，很早之前就有双卡双待的手机了，尽管IMSI的定义差不多，但是我们需要获取的不仅仅是一个IMSI，而是两个IMSI</p>
<ol>
<li>获取当前使用的IMSI可以直接通过上面的获取方法进行获取</li>
<li>获取第二个IMSI则需要根据不同平台，不同厂商进行处理，网上有些牛人已经总结了不错的方法，点击<a href="http://blog.csdn.net/zc0727/article/details/15541289" target="_blank" rel="external">这里</a></li>
</ol>
<h2 id="总结">总结</h2><ul>
<li>IMEI是与手机绑定的。IMSI是与SIM（Subscriber Identity Module，用户识别模块）或者USIM（Universal Subscriber Identity Module，全球用户身份模块）</li>
<li>IMSI不等同于手机号码，更多是一个映射，该IMSI对应一个指定的手机号码</li>
<li>代码上获取手机号码据传是有一些方法的，但是不靠谱，我们可以自己猜想一下，tips：补卡，换卡</li>
</ul>
<h1 id="ICCID">ICCID</h1><h2 id="定义-1">定义</h2><p>ICCID(Integrate circuit card identity)：集成电路卡识别码（固化在手机SIM卡中） ICCID为IC卡的唯一识别号码，共有20位数字组成，<strong>存储在SIM卡中</strong></p>
<h2 id="组成-1">组成</h2><p><code>ICCID=XXXXXX 0MFSS YYGXX XXXXX</code></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>中国移动编码格式</td>
<td>89860 0MFSS YYGXX XXXXP</td>
</tr>
<tr>
<td>中国联通编码格式</td>
<td>89860 1YYMH AAAXX XXXXP</td>
</tr>
<tr>
<td>中国电信编码格式</td>
<td>89860 3MYYH HHXXX XXXXX</td>
</tr>
</tbody>
</table>
<p>具体的编码格式说明详见<a href="http://baike.baidu.com/item/iccid" target="_blank" rel="external">这里</a></p>
<h2 id="获取方法-1">获取方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取sim卡序列号iccid 不同于misi</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> context</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getICCID</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">    <span class="keyword">return</span> telephonyManager.getSimSerialNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="KI">KI</h1><h2 id="定义-2">定义</h2><p>KI(Key identifier)：是SIM卡与运营商之间加密数据传递的密钥，<strong>存储在SIM卡中</strong>。GSM的加密方式是一种称为comp-128的数字加密运算，当系统进行验证时会同时使用Ki及IMSI，经过一连串系统安全认证讯息后产生随机变量，并以A3算法进行加密运算与手机内存资料进行比对，当身份确认无误后始可入网。目前GSM使用的KI长度是16 bytes，相当于128bits，若非经过特殊译码程序，使用者无法读取Ki，安全性极高，使用者无须担心有被盗打电话的顾虑</p>
<h2 id="扩展-1">扩展</h2><p>只要知道SIM卡的KI、IMSI值，我们就可以通过软件仿真出SIM卡的功能，甚至可以利用多组KI、IMSI值，用一张微处理器卡片来同时仿真本来需要多张SIM所完成的功能，这就是“一卡多号”技术。</p>
<h1 id="总结-1">总结</h1><ul>
<li>一张SIM卡，里面有ICCID，也有IMSI。 ICCID是卡的标识，IMSI是用户的标识。</li>
<li>ICCID只是用来区别SIM卡，不作接入网络的鉴权认证。而IMSI在接入网络的时候，会到运营商的服务器中进行验证。</li>
<li>ICCID可以伪造，可以用一张空白多号卡，写入IMSI和KI，只要是经过破解的IMSI和KI，就可以接入网络，而ICCID可以任意20位数字。</li>
<li>iPhone手机在激活的时候，会把ICCID和IMSI一起发送到苹果服务器端进行验证。特别是有锁的手机，就使用IMSI来判断是否合法运营商，如果不合法，就无法激活。ICCID作为SIM卡标识，在激活的时候被记录下来，直到下次刷机，在服务端的记录都不会被改变。</li>
</ul>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="http://baike.baidu.com/link?url=daVUmf1YoGhS_RPd1tiScA9ycDVhINEVJLeinTReLM0eoKbXtmzQ41SOZzcUdH5pCRXlgj_m17yk0Cdzfz0wT_" target="_blank" rel="external">http://baike.baidu.com/link?url=daVUmf1YoGhS_RPd1tiScA9ycDVhINEVJLeinTReLM0eoKbXtmzQ41SOZzcUdH5pCRXlgj_m17yk0Cdzfz0wT_</a></li>
<li><a href="http://mcclist.com/mobile-network-codes-country-codes.asp" target="_blank" rel="external">http://mcclist.com/mobile-network-codes-country-codes.asp</a></li>
<li><a href="http://blog.csdn.net/zc0727/article/details/15541289" target="_blank" rel="external">http://blog.csdn.net/zc0727/article/details/15541289</a></li>
<li><a href="http://www.chinasnow.net/index.php/archives/256" target="_blank" rel="external">http://www.chinasnow.net/index.php/archives/256</a></li>
<li><a href="http://bbs.zol.com.cn/sjbbs/d297_291682.html" target="_blank" rel="external">http://bbs.zol.com.cn/sjbbs/d297_291682.html</a></li>
<li><a href="http://baike.baidu.com/item/iccid" target="_blank" rel="external">http://baike.baidu.com/item/iccid</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>你应该需要知道的Android设备标识。<br>]]>
    
    </summary>
    
      <category term="Android UIDS" scheme="http://caizhitao.com/tags/Android-UIDS/"/>
    
      <category term="Android Develop" scheme="http://caizhitao.com/categories/Android-Develop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Android设备信息】IMEI、MEID、PESN、ESN]]></title>
    <link href="http://caizhitao.com/2015/11/27/android-uids-IMEI-MEID-PESN-ESN/"/>
    <id>http://caizhitao.com/2015/11/27/android-uids-IMEI-MEID-PESN-ESN/</id>
    <published>2015-11-27T07:29:55.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>你应该需要知道的Android设备标识。<br><a id="more"></a></p>
<h1 id="IMEI">IMEI</h1><h2 id="定义">定义</h2><p>IMEI(International Mobile Equipment Identity)：国际移动通讯设备识别号的缩写，由15位数字组成，主要用于<strong>GSM</strong>系统，因此与每台移动/联通手机一一对应，而且该码是全世界唯一的。每一部手机在组装完成后都将被赋予一个全球唯一的一组号码，这个号码从生产到交付使用都将被制造生产的厂商所记录。<strong>移动/联通上可以通过在拨号键盘上输入*#06#进行查询imei</strong>。</p>
<h2 id="组成">组成</h2><p>IMEI由15位数字组成，其组成为：<code>IMEI = TAC + FAC + SNR + SP</code></p>
<ul>
<li><code>TAC</code>(TYPE APPROVAL CODE)：IMEI前6位，<strong>标识型号核准号码，一般代表机型</strong>。由欧洲型号认证中心分配。TAC码前三位在不同的时期会发生变化，过去的TAC码前三位在现在的手机上不会出现</li>
<li><code>FAC</code>(FAC-Final Assembly Code)：IMEI第7位到第8位，<strong>标识最后装配号，一般代表产地</strong>，由厂家编码，通常表示生产厂家及其装配地。也就是我们说的行货认证 </li>
<li><code>SNR</code>(Serial Number)：IMEI第9位到第14位，<strong>标识串号，一般代表生产顺序号</strong>，也由厂家分配。识别每个TAC和FAC中的某个设备的。每一部手机的SNR都不会一样．简单的说该号码可以说明手机出产日期的先后，通常数值越大说明该机型出厂时间越晚，所以如果一部刚上市不久的手机的IMEI上出现了6位的数字你就得小心了，因为刚上市不久的手机其SNR最多不会超过四位，大家可以在购机时留意一下。也许这可以作为鉴别手机是否被JS修改IMEI的好办法之一。</li>
<li><code>SP</code>：IMEI第15位，<strong>检验码</strong>，过去通常为0，现在市面上的手机基本都会由厂家进行配置这个校验码</li>
</ul>
<h2 id="获取方法">获取方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取IMEI</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIMEI</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">        <span class="keyword">if</span> (TelephonyManager.PHONE_TYPE_GSM == telephonyManager.getPhoneType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> telephonyManager.getDeviceId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展">扩展</h2><h3 id="17位IMEI">17位IMEI</h3><p><strong>有些手机在IMEI上做了自己的定义，如：爱立信手机，三星V200在待机时输入*#06#就会出现17位的IMEI，而最后两位的主要作用是用来识别软件版本，一般来说数值越低版本也越低</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取IMEI的版本号</span><br><span class="line"> * 部分GSM手机上拨号键盘输入*#06#之后会出现的IMEI/SV(software version)</span><br><span class="line"> * 一般在三星的手机上输入*#06#最后会出现15位IMEI + "/01"的内容，后面的就是描述软件版本号的</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIMEISV</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">        <span class="keyword">if</span> (TelephonyManager.PHONE_TYPE_GSM == telephonyManager.getPhoneType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> telephonyManager.getDeviceSoftwareVersion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两个IMEI">两个IMEI</h3><p><strong>双卡双待的手机有两个通讯芯片，相当于2个手机装在一个手机壳里面，每个通讯芯片都需要有IMEI标识，于是输入*#06#之后</strong></p>
<ol>
<li>可能会显示2个IMEI</li>
<li>可能会显示1个IMEI</li>
<li>可能会显示1个MEID</li>
<li>可能会显示2个MEID</li>
<li>可能会显示1个IMEI+1个MEID</li>
</ol>
<p>但是上面的获取方法只能获取1个，如果是2个以上的话，剩下那个需要其他方法才能获取到</p>
<h3 id="IMEI校验">IMEI校验</h3><ul>
<li>尽管imei定义可以理解为每台手机唯一，但是实际上很容易被改，安装了Xposted(目前好像在Android 5.x以上系统不好使)框架，然后安装Xprivacy就可以轻松替换imei</li>
<li>可以通过校验算法进行一次校验，过滤一些小白随便起的imei</li>
<li>最好不要通过长度进行判断imei是否有效</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IMEI 校验算法(SP计算方法):</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 分别取偶数位*<span class="number">2</span>，得出<span class="number">7</span>组结果</span><br><span class="line"><span class="number">2</span>. 针对这<span class="number">7</span>组结果，每组进行（十位数数字 + 个位数数字)，得出新的<span class="number">7</span>组结果，将这<span class="number">7</span>组结果相加得出和<span class="number">1</span></span><br><span class="line"><span class="number">3</span>. 取imei中的所有奇数位数字（<span class="number">7</span>个），全部相加得出和<span class="number">2</span></span><br><span class="line"><span class="number">4</span>. 和<span class="number">1</span> + 和<span class="number">2</span> 得出结果，如果结果的个位数数字是<span class="number">0</span>，那么校验码就为<span class="number">0</span>，否则用<span class="number">10</span>减去个位数数字即可以得出校验码</span><br><span class="line"></span><br><span class="line">e.g.</span><br><span class="line"></span><br><span class="line">imei: <span class="number">35</span> <span class="number">89</span> <span class="number">01</span> <span class="number">80</span> <span class="number">69</span> <span class="number">72</span> <span class="number">41</span> <span class="number">7</span>(最后这个<span class="number">7</span>为我们要计算出来的)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 偶数位乘以<span class="number">2</span>得到<span class="number">5</span>*<span class="number">2</span>=<span class="number">10</span> <span class="number">9</span>*<span class="number">2</span>=<span class="number">18</span> <span class="number">1</span>*<span class="number">2</span>=<span class="number">02</span> <span class="number">0</span>*<span class="number">2</span>=<span class="number">00</span> <span class="number">9</span>*<span class="number">2</span>=<span class="number">18</span> <span class="number">2</span>*<span class="number">2</span>=<span class="number">04</span> <span class="number">1</span>*<span class="number">2</span>=<span class="number">02</span></span><br><span class="line"><span class="number">2</span>. 计算和<span class="number">1</span>：(<span class="number">1</span>+<span class="number">0</span>)+(<span class="number">1</span>+<span class="number">8</span>)+(<span class="number">0</span>+<span class="number">2</span>)+(<span class="number">0</span>+<span class="number">0</span>)+(<span class="number">1</span>+<span class="number">8</span>)+(<span class="number">0</span>+<span class="number">4</span>)+(<span class="number">0</span>+<span class="number">2</span>)=<span class="number">27</span></span><br><span class="line"><span class="number">3</span>. 计算和<span class="number">2</span>：<span class="number">3</span>+<span class="number">8</span>+<span class="number">0</span>+<span class="number">8</span>+<span class="number">6</span>+<span class="number">7</span>+<span class="number">4</span> = <span class="number">36</span></span><br><span class="line"><span class="number">4</span>. <span class="number">36</span>+<span class="number">27</span> = <span class="number">63</span> 校验码为 <span class="number">10</span>-<span class="number">3</span> = <span class="number">7</span>.</span><br><span class="line"></span><br><span class="line">加上校验码的最终imei：<span class="number">35</span> <span class="number">89</span> <span class="number">01</span> <span class="number">80</span> <span class="number">69</span> <span class="number">72</span> <span class="number">41</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h1 id="MEID">MEID</h1><h2 id="定义-1">定义</h2><p>MEID(Mobile Equipment Identifier)：移动设备识别码是CDMA手机的身份识别码，也是每台CDMA手机或通讯平板唯一的识别码。通过这个识别码，网络端可以对该手机进行跟踪和监管。<strong>主要用于CDMA制式的手机</strong>。MEID的数字范围是十六进制的，和IMEI的格式类似。<strong>一般为电信的手机，同样可以通过在拨号键盘上输入*#06#进行查询</strong></p>
<h2 id="组成-1">组成</h2><p>MEID，56bits，由14个十六进制字符标识，<code>MEID = 区域码（前2位）+生厂商编号（接着6位） + 串号（接着6位） + 校验位（最后一位）</code>，其中，校验位不参与空中传输。</p>
<table>
<thead>
<tr>
<th>Regional code</th>
<th>Manufacturer code</th>
<th>Serial number</th>
<th>CD</th>
</tr>
</thead>
<tbody>
<tr>
<td>RR</td>
<td>XXXXXX</td>
<td>ZZZZZZ</td>
<td>C</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>RR</td>
<td>开头的0xA表示CDMA手机，如果是0x9, 就表示多模手机，一般特指双卡双待。</td>
</tr>
<tr>
<td>XXXXXX</td>
<td>范围 000000-FFFFFF，由官方分配，厂商生产编号</td>
</tr>
<tr>
<td>ZZZZZZ</td>
<td>范围 000000-FFFFFF，厂商分配给每台终端的流水号</td>
</tr>
<tr>
<td>CD</td>
<td>0-F，校验码</td>
</tr>
</tbody>
</table>
<h2 id="获取方法-1">获取方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMEID</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">        <span class="keyword">if</span> (TelephonyManager.PHONE_TYPE_CDMA == telephonyManager.getPhoneType()) &#123;</span><br><span class="line">            <span class="keyword">return</span> telephonyManager.getDeviceId();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展-1">扩展</h2><ul>
<li><strong>MEID理论上是14位（不包括校验位）的长度，但是有些机子会是16位（不包括校验位）的长度，<code>典型的例子：14位的MEID：0xA0，16位的MEID：0x00A0</code>，为了统一，可以直接截取后面14位作为最后的MEID</strong></li>
<li>MEID的申请，是需要付费的。价格是每1M范围的MEID的费用是8000美元，每增加1M范围的MEID号码需要额外付费8000美元</li>
<li>MEID号码是由Telecommunications Industry Association（TIA）进行分配管理的</li>
<li>MEID号码的查看，没有一个通用的方法，由各手机制造商自己设置。可以通过查看手机说明书得到查看MEID号码的方法</li>
<li>MEID校验算法：<ol>
<li>将MEID偶数位数字分别乘以2，得到的7组结果</li>
<li>针对这7组结果，每组进行（十位数数字 + 个位数数字)，得出新的7组结果，将这7组结果相加得出和1</li>
<li>将MEID奇数位数字相加得到和2</li>
<li>和1 +和2，如果得出的数个位是0，则校验位为0，否则为10(这里的10是16进制)减去个位数<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MEID</span>: <span class="string">AF 01 23 45 0A BC DE C(最后这个C为我们要计算出来的)</span></span><br><span class="line"></span><br><span class="line"><span class="mathematica"><span class="number">1.</span> 偶数位乘以<span class="number">2</span>得到各组结果:F*<span class="number">2</span>=<span class="number">1</span><span class="keyword">E</span>,<span class="number">1</span>*<span class="number">2</span>=<span class="number">02</span>,<span class="number">3</span>*<span class="number">2</span>=<span class="number">06</span>,<span class="number">5</span>*<span class="number">2</span>=<span class="number">0</span>A,A*<span class="number">2</span>=<span class="number">14</span>,<span class="keyword">C</span>*<span class="number">2</span>=<span class="number">18</span>,<span class="keyword">E</span>*<span class="number">2</span>=<span class="number">1</span><span class="keyword">C</span></span><br><span class="line"><span class="number">2.</span> 计算上面各组结果的个位数和十位数之和得出和<span class="number">1</span>:(<span class="number">1</span>+<span class="keyword">E</span>)+(<span class="number">0</span>+<span class="number">2</span>)+(<span class="number">0</span>+<span class="number">6</span>)+(<span class="number">0</span>+A)+(<span class="number">1</span>+<span class="number">4</span>)+(<span class="number">1</span>+<span class="number">8</span>)+(<span class="number">1</span>+<span class="keyword">C</span>)=<span class="number">3</span><span class="keyword">C</span>(<span class="number">16</span>进制下)</span><br><span class="line"><span class="number">3.</span> 将原始MEID的奇数位相加得出和<span class="number">2</span>:A+<span class="number">0</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">0</span>+B+<span class="keyword">D</span>=<span class="number">28</span>(<span class="number">16</span>进制下)</span><br><span class="line"><span class="number">4.</span> 和<span class="number">1</span>+和<span class="number">2</span>:<span class="number">3</span><span class="keyword">C</span>+<span class="number">28</span>=<span class="number">64</span>(<span class="number">16</span>进制下)，于是最终检验位<span class="number">10</span>-<span class="number">4</span>=<span class="keyword">C</span></span><br><span class="line"></span><br><span class="line">加上校验码的最终MEID：AF <span class="number">01</span> <span class="number">23</span> <span class="number">45</span> <span class="number">0</span>A BC DE <span class="keyword">C</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h1 id="ESN/pESN">ESN/pESN</h1><h2 id="定义-2">定义</h2><p>ESN(Electronic Serial Numbers)：电子序列号。在CDMA 系统中，是鉴别一个物理硬件设备唯一的标识。也就是说每个手机都用这个唯一的ID来鉴别自己, 就跟人的身份证一样。<strong>一个ESN有32 bits</strong>, 随着CDMA移动设别的增多，ESN已经不够用了，所以推出了位数更多的MEID。<strong>ESN用8位的16进制来表示，如0x801EA066。</strong></p>
<p>pESN(pseudo ESN):伪ESN。pESN的推出是为了解决前向兼容的问题，<strong>pESN的格式与ESN是完全一样的，唯一的区别是pESN是采用0x80开头的</strong>。将MEID转为pESN，就可以在支持ESN的C网内正常使用。</p>
<h2 id="扩展-2">扩展</h2><ul>
<li>MEID转化为pESN具体的方法是，56 bits的MEID通过SHA-1 hash算法，挑出后6位，然后在开头加上0x80。<strong>pESN并不是唯一的，是可能会重复的，但pESN不会跟ESN重复，因为开头强制加了0x80</strong>；java中提供了MessageDigest这个类来实现了一系列的hash算法，可以通过调用该类来进行运算，计算过程中注意byte和hexstring之间的转换即可。</li>
<li>一个手机只能有一个ESN或一个MEID。如6800、6900均是ESN码；但6950开始就采用MEID码了。</li>
<li>带ESN或MEID码的手机都可以支持ESN的CDMA网络内正常使用，而ESN码的手机不能在只支持MEID的CDMA网络内使用。</li>
<li>目前中国电信的C网应该已经开始采用MEID鉴权了，从2005年开始MEID开始替换ESN。</li>
</ul>
<h1 id="总结">总结</h1><ul>
<li>CDMA系统上，我们叫MEID，GSM系统上，我们叫IMEI</li>
<li><strong>正常情况下</strong>，手机上我们获取到<code>14位MEID</code>，或者<code>15位IMEI</code></li>
</ul>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="http://www.cnblogs.com/flyme/p/3317013.html" target="_blank" rel="external">http://www.cnblogs.com/flyme/p/3317013.html</a></li>
<li><a href="http://my.oschina.net/adairs/blog/418954?fromerr=9LQoQQpv" target="_blank" rel="external">http://my.oschina.net/adairs/blog/418954?fromerr=9LQoQQpv</a></li>
<li><a href="http://www.miui.com/article-336-1.html" target="_blank" rel="external">http://www.miui.com/article-336-1.html</a></li>
<li><a href="http://www.lainzy.net/post/157.html" target="_blank" rel="external">http://www.lainzy.net/post/157.html</a></li>
<li><a href="http://baike.baidu.com/view/2823315.htm" target="_blank" rel="external">http://baike.baidu.com/view/2823315.htm</a></li>
<li>[扩展]<a href="http://wenku.baidu.com/view/9aed75f37c1cfad6195fa70e.html" target="_blank" rel="external">http://wenku.baidu.com/view/9aed75f37c1cfad6195fa70e.html</a> </li>
<li>[扩展]<a href="http://www.docin.com/p-555856641.html" target="_blank" rel="external">http://www.docin.com/p-555856641.html</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>你应该需要知道的Android设备标识。<br>]]>
    
    </summary>
    
      <category term="Android UIDS" scheme="http://caizhitao.com/tags/Android-UIDS/"/>
    
      <category term="Android Develop" scheme="http://caizhitao.com/categories/Android-Develop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[获取当前顶端包名【兼容所有系统】]]></title>
    <link href="http://caizhitao.com/2015/09/29/get-top-package-name/"/>
    <id>http://caizhitao.com/2015/09/29/get-top-package-name/</id>
    <published>2015-09-29T08:19:28.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>获取顶端包名功能在Android 5.0系统前后发生重大变化，经过各种搬运加测试后，得出一些通用解决方案，虽然没有一种简单通用的方法，但是目前已经有可以兼容所有系统的方案。<br><a id="more"></a></p>
<h1 id="Android_5-0_之前">Android 5.0 之前</h1><h2 id="直接通过getRunningTasks方法进行获取">直接通过getRunningTasks方法进行获取</h2><h3 id="用法">用法</h3><p>需要添加下面权限:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.GET_TASKS"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">ComponentName cn = activityManager.getRunningTasks(<span class="number">1</span>).get(<span class="number">0</span>).topActivity;</span><br><span class="line">String currentPkgName = cn.getPackageName(); <span class="comment">// 当前显示在顶端的包名</span></span><br></pre></td></tr></table></figure>
<h3 id="结论">结论</h3><ol>
<li>通过上面的方法，我们就可以获取到当前显示在顶端的包名，很多锁屏类，或者应用锁的核心就是这块</li>
<li>可惜的是5.0(API &gt; 20) 之后就不能再用这个方法了，<strong>根据下面的官方说明，Android 5.0系统之后</strong> <code>getRunningTasks</code> <strong>方法被弃用了，经过实际测试之后，这个方法仅仅只能返回自身应用信息以及一些公开包名的信息(如：桌面，设置等)</strong><br> <img src="/img/获取当前顶端包名/1.png" alt=""></li>
</ol>
<h1 id="Android_5-0_之后">Android 5.0 之后</h1><h2 id="通过getRunningAppProcesses方法进行获取">通过getRunningAppProcesses方法进行获取</h2><p>原理：通过获取当前在顶端运行的进程，遍历该进程下的所有包名，得出该进程下的包名列表</p>
<h3 id="使用方法">使用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查当前在最前端运行的进程包名列表</span><br><span class="line"> * <span class="doctag">@param</span> context</span><br><span class="line"> * <span class="doctag">@return</span> </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String[] getForegroundPkgName(Context context) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ActivityManager activityManager = (ActivityManager) context.getApplicationContext().getSystemService(</span><br><span class="line">                Context.ACTIVITY_SERVICE);</span><br><span class="line">        List&lt;ActivityManager.RunningAppProcessInfo&gt; processInfos = activityManager.getRunningAppProcesses();</span><br><span class="line">        <span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo processInfo : processInfos) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processInfo.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) &#123;</span><br><span class="line">                Log.i(<span class="string">"test"</span>, <span class="string">"当前顶端进程的信息"</span>);</span><br><span class="line">                Log.i(<span class="string">"test"</span>, <span class="string">"进程id: "</span> + processInfo.pid);</span><br><span class="line">                Log.i(<span class="string">"test"</span>, <span class="string">"进程名  : "</span> + processInfo.processName);</span><br><span class="line">                Log.i(<span class="string">"test"</span>, <span class="string">"该进程下可能存在的包名"</span>);</span><br><span class="line">                <span class="keyword">for</span> (String pkgName : processInfo.pkgList) &#123;</span><br><span class="line">                    Log.i(<span class="string">"test"</span>, <span class="string">"  "</span> + pkgName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> processInfo.pkgList;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结论-1">结论</h3><ol>
<li>正如原理所描述，它返回的是当前在顶端运行的进程的包名列表，正常情况下，我们开发的时候都是一个进程对应一个包名，但是如果是大公司的话，可能会将旗下所有应用共享同一个进程，于是这里就会返回一个包名数组，所以这个方法只能说满足大部分日常需求</li>
<li>经过最近的测试，还发现了在一些新的机器上（国产为主，代表:小米 v5.0.2系统）已经不能再使用这种方案了，因为这个方法在这些机器上，只能获取到自己应用的信息，变得和 <code>getRunningTasks</code> 在Android 5.0系统上的表现差不多</li>
<li>需要继续寻找新方案…</li>
</ol>
<h2 id="通过Android_5-0提供的新API进行获取">通过Android 5.0提供的新API进行获取</h2><p>Android 5.0之后提供了一个新的API: <code>UsageStatsManager</code>，通过该API我们可以准确获取到当前顶端的包名信息</p>
<h3 id="使用方法-1">使用方法</h3><p>需要添加下面的权限:</p>
<ol>
<li>添加下面权限:</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">uses-permission</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"android.permission.PACKAGE_USAGE_STATS"</span></span><br><span class="line">    <span class="attribute">tools:ignore</span>=<span class="value">"ProtectedPermissions"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>引导用户到设置页面为自身应用开启 <strong>有权查看使用情况的应用</strong> 的权限:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些机子上是没法直接到达上面的设置页面的，所以还需要 ``try catch`` 上面的代码，catch到错误之后尝试后备方案——进入到该设置页面的上一级页面</span></span><br><span class="line"></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_SECURITY_SETTINGS);</span><br><span class="line">intent.setComponent(</span><br><span class="line">        <span class="keyword">new</span> ComponentName(<span class="string">"com.android.settings"</span>, <span class="string">"com.android.settings.Settings$SecuritySettingsActivity"</span>));</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<ol>
<li>通过下面的代码即可获取顶端包名:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取当前在顶端运行的应用包名(适用于Andriod 5.0以上的机器)</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 通过AndroidL的新API——UsageStatsManager来进行获取，但是需要配置权限和需要用户允许获取</span><br><span class="line"> * 所以需要本方法能准确获取，但是体验不太好，建议先用getRunningAppProcesses方法进行获取，不行采用这个方法</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p/&gt;</span><br><span class="line"> * 使用本方法之前需要配置下面内容</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * 1. 权限配置</span><br><span class="line"> *   a. 需要在AndroidManifest.xml中配置权限</span><br><span class="line"> *</span><br><span class="line"> *         &lt;uses-permission</span><br><span class="line"> *             android:name="android.permission.PACKAGE_USAGE_STATS"</span><br><span class="line"> *             tools:ignore="ProtectedPermissions" /&gt;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *   b. 然后还要在AndroidManifest.xml中的manifest标签中配置</span><br><span class="line"> *         xmlns:tools="http://schemas.android.com/tools"</span><br><span class="line"> *</span><br><span class="line"> * 2. 需要用户允许这个应用能获取用户数据统计信息的权限</span><br><span class="line"> *        Intent intent = new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);</span><br><span class="line"> *        startActivity(intent);</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> time_ms 从$&#123;time_ms&#125;内找出最近显示在顶端的包名</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTopRunningPkgNameAboveAndroidL2</span><span class="params">(Context context, <span class="keyword">long</span> time_ms)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 通过Android 5.0 之后提供的新api来获取最近一段时间内的应用的相关信息</span></span><br><span class="line">   String topPackageName = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 根据最近time_ms毫秒内的应用统计信息进行排序获取当前顶端的包名</span></span><br><span class="line">         <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">         UsageStatsManager usage = (UsageStatsManager) context.getSystemService(<span class="string">"usagestats"</span>);</span><br><span class="line">         List&lt;UsageStats&gt; usageStatsList = usage.queryUsageStats(UsageStatsManager.INTERVAL_BEST, time - time_ms, time);</span><br><span class="line">         <span class="keyword">if</span> (usageStatsList != <span class="keyword">null</span> &amp;&amp; usageStatsList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SortedMap&lt;Long, UsageStats&gt; runningTask = <span class="keyword">new</span> TreeMap&lt;Long, UsageStats&gt;();</span><br><span class="line">            <span class="keyword">for</span> (UsageStats usageStats : usageStatsList) &#123;</span><br><span class="line">               runningTask.put(usageStats.getLastTimeUsed(), usageStats);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (runningTask.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            topPackageName = runningTask.get(runningTask.lastKey()).getPackageName();</span><br><span class="line">            Log.i(<span class="string">"test"</span>, <span class="string">"##当前顶端应用包名:"</span> + topPackageName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> topPackageName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>如果希望能检测用户是否已经允许本应用有权查看组件使用情况，可以通过下面代码进行检查:</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">    PackageManager packageManager = context.getPackageManager();</span><br><span class="line">    ApplicationInfo applicationInfo = packageManager.getApplicationInfo(context.getPackageName(), <span class="number">0</span>);</span><br><span class="line">    AppOpsManager appOpsManager = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE);</span><br><span class="line">    <span class="keyword">int</span> mode = appOpsManager</span><br><span class="line">            .checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, applicationInfo.uid, applicationInfo.packageName);</span><br><span class="line">    <span class="keyword">return</span> mode == AppOpsManager.MODE_ALLOWED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结论-2">结论</h3><ol>
<li>使用这个方法之前<strong>需要用户允许应用有权查看组件使用情况</strong>，然后才有数据返回</li>
<li>新的API能完美进行，就是需要添加新的权限和做一下用户引导</li>
<li>如果获取的时间设置得太短，并且这个时间内又没有发生改变的话，那么是获取不到最新的顶端的包名情况的</li>
<li><strong>最重要的是</strong>，最近又发现在一些机器上（国产为主，魅族领头，LG G3在列），是没有<strong>允许应用有权查看使用组件的情况</strong>的设置页面的，于是，我们大喊一声，妈蛋~</li>
<li>需要继续寻找新方案…</li>
</ol>
<h1 id="总结(截止至2015-09-22)">总结(截止至2015-09-22)</h1><p>目前还不能全面兼容Android 5.0系统，还需要继续寻找新的方案</p>
<h1 id="后续尝试">后续尝试</h1><h2 id="尝试dunpsys命令">尝试dunpsys命令</h2><p>如果是在adb shell中使用 <code>dumpsys activity activities</code> 的话，倒是可以获取到顶端的包名，但是代码中的话，除非你拥有和系统应用的签名，否则，是不能使用 <code>android.permission.DUMP</code> 权限的，也就不能使用 <code>dumpsys</code> 命令了</p>
<p><strong>continue…</strong></p>
<p><a name="proc" id="chap-proc"></a></p>
<h2 id="尝试通过/proc目录进行判断">尝试通过/proc目录进行判断</h2><p><code>/proc</code> 目录是存放当前系统运行中的一些信息，包括各个进程，cpu，内存，启动时长等，具体目录介绍可以参照<a href="http://blog.chinaunix.net/uid-23960192-id-3549140.html" target="_blank" rel="external">这里</a>，偶然间发现了<a href="http://stackoverflow.com/questions/30619349/android-5-1-1-and-above-getrunningappprocesses-returns-my-application-packag" target="_blank" rel="external">stackoverflow</a> 上的这个神贴，就是用这个方法的，无须任何权限，但是作者也说到缺乏测试，而我这边自己测试之后发现不是很理想，很多机子都不行</p>
<p><strong>ps:</strong></p>
<ol>
<li><p>正常的 <code>cgroup</code> 文件（Nexus4）上结果如下:</p>
<p> <img src="/img/获取当前顶端包名/2.png" alt=""> </p>
</li>
<li><p>附上几张在天朝不同机子上的 <code>cgroup</code> 文件解读图：</p>
</li>
</ol>
<ul>
<li>魅族mx4 Flyme OS 4.2.8.2C Android 4.4.2 <img src="/img/获取当前顶端包名/3.png" alt=""></li>
<li>魅族mx4 pro Flyme OS 4.5.5A Android 5.0.1 <img src="/img/获取当前顶端包名/4.png" alt=""></li>
<li>魅族m2 note Flyme OS 4.5.3A Android 5.1 <img src="/img/获取当前顶端包名/5.png" alt=""></li>
<li>小米2s MIUI 5.7.16 Android 5.0.2 <img src="/img/获取当前顶端包名/6.png" alt=""></li>
</ul>
<p><strong>continue…</strong></p>
<h2 id="通过accessibility-service服务进行">通过accessibility-service服务进行</h2><p>方法参考<a href="http://stackoverflow.com/questions/3873659/android-how-can-i-get-the-current-foreground-activity-from-a-service/27642535#27642535" target="_blank" rel="external">这里</a>，经过测试，能够不用在配置新权限的前提下完美运行，但是也有一些问题</p>
<blockquote>
<ol>
<li>Each user must enable the service via Android’s accessibility settings in order for the AccessibilityEvents to be received.<br>The service generally runs until the user explicitly disables it. You can make the service stop itself if needed, but I don’t know of any way to programmatically restart it correctly if you’ve stopped it.</li>
<li>When a user tries to enables the AccessibilityService, they can’t press the OK button if an app has placed an overlay on the screen. Some apps that do this are Velis Auto Brightness and Lux. This can be confusing because the user might not know why they can’t press the button or how to work around it.</li>
<li>The AccessibilityService won’t know the current activity until the first change of activity.</li>
</ol>
</blockquote>
<p><strong>continue…</strong></p>
<h2 id="结语">结语</h2><p>总结下来，Android 5.0以上的机子目前有4种方法可以尝试，每种方法都有一些优点和缺陷，在找到一个完美的方法之前，我们可以依次采用下面的方法来尽量覆盖多一点机型</p>
<ol>
<li><code>getRunningAppProcess</code></li>
<li><code>通过观察proc</code></li>
<li><code>UsageStatsManager</code></li>
<li><code>Accessibility-service</code></li>
</ol>
<h1 id="后记&amp;&amp;最终解决方案">后记&amp;&amp;最终解决方案</h1><p>在我准备放弃的时候，我又重新看了一下 <a href="#chap-proc">通过观察proc</a> 获取当前运行中的进程这个方法，发现其核心代码在于通过判断<code>oom-score</code>来识别当前运行的顶端应用的，这个是什么原理呢？查阅了一下资料，这个涉及到 <code>Linux OOM Killer</code>机制:</p>
<blockquote>
<p>Linux 内核存在一个OOM killer（Out-Of-Memory killer），该机制会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程，为了防止内存耗尽而内核会把该进程杀掉，而每个进程都有一个oom_score属性，oomkiller会杀掉oom_score较大的进程</p>
</blockquote>
<p>那么究竟杀掉那个进程呢，其实是受下面3个文件的影响：</p>
<ul>
<li><code>/proc/$PID/oom_adj</code>：用于调整oom_score的分数，范围在[-17,15]，当为-17时，oom_score将变为0，标识禁止杀死该进程</li>
<li><code>/proc/$PID/oom_score</code>：标识最终的分数，分数越大，进程越有可能被杀</li>
<li><code>/proc/$PID/oom_score_adj</code>：从Linux 2.6.36开始都安装了/proc/$PID/oom_score_adj，此后替换为/proc/$PID/oom_adj，即使当前是对/proc/$PID/oom_adj进行的设置，在内核内部进行变换后的值也是针对/proc/$PID/oom_score_adj设置的</li>
</ul>
<p>3个文件的具体manpage可以参考<a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="external">这里</a>，下面是我截取的一些关键内容 </p>
<blockquote>
<p><strong>/proc/[pid]/oom_adj (since Linux 2.6.11)</strong></p>
<p>This file can be used to adjust the score used to select which process should be killed in an out-of-memory (OOM) situation.  The kernel uses this value for a bit-shift operation of the process’s oom_score value: valid values are in the range -16 to +15, plus the special value -17, which disables OOM-killing altogether for this process.  A positive score increases the likelihood of this process being killed by the OOM-killer; a negative score decreases the likelihood.</p>
<p>The default value for this file is 0; a new process inherits its parent’s oom_adj setting.  A process must be privileged (CAP_SYS_RESOURCE) to update this file.  Since Linux 2.6.36, use of this file is deprecated in favor of /proc/[pid]/oom_score_adj.</p>
<p><strong>/proc/[pid]/oom_score (since Linux 2.6.11)</strong></p>
<p>This file displays the current score that the kernel gives to this process for the purpose of selecting a process for the OOM-killer.  A higher score means that the process is more likely to be selected by the OOM-killer.  The basis for this score is the amount of memory used by the process, with increases (+) or decreases (-) for factors including:</p>
<ul>
<li>whether the process creates a lot of children using fork(2) (+);</li>
<li>whether the process has been running a long time, or has used a lot of CPU time (-);</li>
<li>whether the process has a low nice value (i.e., &gt; 0) (+);</li>
<li>whether the process is privileged (-); and</li>
<li>whether the process is making direct hardware access (-).</li>
</ul>
<p>The oom_score also reflects the adjustment specified by the oom_score_adj or oom_adj setting for the process.</p>
<p><strong>/proc/[pid]/oom_score_adj (since Linux 2.6.36)</strong><br>This file can be used to adjust the badness heuristic used to select which process gets killed in out-of-memory conditions.  The badness heuristic assigns a value to each candidate task ranging from 0 (never kill) to 1000 (always kill) to determine which process is targeted.  The units are roughly a proportion along that range of allowed memory the process may allocate from, based on an estimation of its current memory and swap use.  For example, if a task is using all allowed memory, its badness score will be 1000.  If it is using half of its allowed memory, its score will be 500.</p>
<p>There is an additional factor included in the badness score: root processes are given 3% extra memory over other tasks.</p>
<p>The amount of “allowed” memory depends on the context in which the OOM-killer was called.  If it is due to the memory assigned to the allocating task’s cpuset being exhausted, the allowed memory represents the set of mems assigned to that cpuset (see cpuset(7)).  If it is due to a mempolicy’s node(s) being exhausted, the allowed memory represents the set of mempolicy nodes.  If it is due to a memory limit (or swap limit) being reached, the allowed memory is that configured limit.  Finally, if it is due to the entire system being out of memory, the allowed memory represents all allocatable resources.</p>
<p>The value of oom_score_adj is added to the badness score before it is used to determine which task to kill.  Acceptable values range from -1000 (OOM_SCORE_ADJ_MIN) to +1000 (OOM_SCORE_ADJ_MAX).  This allows user space to control the preference for OOM-killing, ranging from always preferring a certain task or completely disabling it from OOM killing.  The lowest possible value, -1000, is equivalent to disabling OOM- killing entirely for that task, since it will always report a badness score of 0.</p>
<p>Consequently, it is very simple for user space to define the amount of memory to consider for each task.  Setting a oom_score_adj value of +500, for example, is roughly equivalent to allowing the remainder of tasks sharing the same system, cpuset, mempolicy, or memory controller resources to use at least 50% more memory.  A value of -500, on the other hand, would be roughly equivalent to discounting 50% of the task’s allowed memory from being considered as scoring against the task.</p>
<p>For backward compatibility with previous kernels, /proc/[pid]/oom_adj can still be used to tune the badness score.  Its value is scaled linearly with oom_score_adj.</p>
<p>Writing to /proc/[pid]/oom_score_adj or /proc/[pid]/oom_adj will change the other with its scaled value.</p>
</blockquote>
<p>通过上面的介绍，估计大家都有些想法了，恩，这是一条可行的路：</p>
<ol>
<li><strong>遍历</strong><code>/proc</code><strong>目录下的子目录，排除系统应用uid</strong></li>
<li><strong>在根据一些其他规则排除一些不符合的应用</strong></li>
<li><strong>排序剩下的应用，得出oom_score分数最少的pid</strong></li>
<li><strong>根据pid找对应的包名</strong></li>
</ol>
<p>原理大概如此，基本代码可以参考<a href="http://stackoverflow.com/questions/30619349/android-5-1-1-and-above-getrunningappprocesses-returns-my-application-packag" target="_blank" rel="external">这里</a>，但是照抄那份代码是不太能在天朝厂商机子上跑通的，需要改进。Anyway，最后我改进代码之后，在我这边手上几台机子测试都没有什么问题，目前也在大规模测试中。</p>
<p><em>ps. 因为一些原因，最终代码还不太好在现在发放出来</em></p>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="http://developer.android.com/reference/android/app/ActivityManager.html#getRunningTasks(int" target="_blank" rel="external">http://developer.android.com/reference/android/app/ActivityManager.html#getRunningTasks(int</a>)</li>
<li><a href="http://chaoqunz.blog.163.com/blog/static/6154877720090495819383/" target="_blank" rel="external">http://chaoqunz.blog.163.com/blog/static/6154877720090495819383/</a></li>
<li><a href="http://blog.csdn.net/qinjuning/article/details/6978560" target="_blank" rel="external">http://blog.csdn.net/qinjuning/article/details/6978560</a></li>
<li><a href="http://blog.csdn.net/qinjuning/article/details/7009824" target="_blank" rel="external">http://blog.csdn.net/qinjuning/article/details/7009824</a></li>
<li><a href="http://m.blog.csdn.net/blog/zsqxiao/44755621" target="_blank" rel="external">http://m.blog.csdn.net/blog/zsqxiao/44755621</a></li>
<li><a href="http://stackoverflow.com/questions/27689276/how-to-get-running-application-activity-name-in-android-5-0l" target="_blank" rel="external">http://stackoverflow.com/questions/27689276/how-to-get-running-application-activity-name-in-android-5-0l</a></li>
<li><a href="http://stackoverflow.com/questions/27087675/cannot-get-foreground-activity-name-in-android-lollipop-5-0-only" target="_blank" rel="external">http://stackoverflow.com/questions/27087675/cannot-get-foreground-activity-name-in-android-lollipop-5-0-only</a></li>
<li><a href="http://stackoverflow.com/questions/28361629/activitynotfoundexception-in-lollipop-when-trying-to-launch-activity-with-intent" target="_blank" rel="external">http://stackoverflow.com/questions/28361629/activitynotfoundexception-in-lollipop-when-trying-to-launch-activity-with-intent</a></li>
<li><a href="http://stackoverflow.com/questions/28296633/android-usage-access-for-android-5-samsung-devices" target="_blank" rel="external">http://stackoverflow.com/questions/28296633/android-usage-access-for-android-5-samsung-devices</a></li>
<li><a href="http://android.stackexchange.com/questions/114525/how-to-access-apps-with-usage-access-setting-on-lg-g3" target="_blank" rel="external">http://android.stackexchange.com/questions/114525/how-to-access-apps-with-usage-access-setting-on-lg-g3</a></li>
<li><a href="http://blog.chinaunix.net/uid-23960192-id-3549140.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-23960192-id-3549140.html</a></li>
<li><a href="http://stackoverflow.com/questions/30619349/android-5-1-1-and-above-getrunningappprocesses-returns-my-application-packag" target="_blank" rel="external">http://stackoverflow.com/questions/30619349/android-5-1-1-and-above-getrunningappprocesses-returns-my-application-packag</a></li>
<li><a href="http://stackoverflow.com/questions/3873659/android-how-can-i-get-the-current-foreground-activity-from-a-service/27642535#27642535" target="_blank" rel="external">http://stackoverflow.com/questions/3873659/android-how-can-i-get-the-current-foreground-activity-from-a-service/27642535#27642535</a></li>
<li><a href="https://github.com/Yhzhtk/note/issues/31" target="_blank" rel="external">https://github.com/Yhzhtk/note/issues/31</a></li>
<li><a href="http://laoxu.blog.51cto.com/4120547/1267097" target="_blank" rel="external">http://laoxu.blog.51cto.com/4120547/1267097</a></li>
<li><a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man5/proc.5.html</a></li>
<li><a href="http://wushank.blog.51cto.com/3489095/1406765" target="_blank" rel="external">http://wushank.blog.51cto.com/3489095/1406765</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>获取顶端包名功能在Android 5.0系统前后发生重大变化，经过各种搬运加测试后，得出一些通用解决方案，虽然没有一种简单通用的方法，但是目前已经有可以兼容所有系统的方案。<br>]]>
    
    </summary>
    
      <category term="Android 系统兼容" scheme="http://caizhitao.com/tags/Android-%E7%B3%BB%E7%BB%9F%E5%85%BC%E5%AE%B9/"/>
    
      <category term="Android Develop" scheme="http://caizhitao.com/categories/Android-Develop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vim即时预览markdown]]></title>
    <link href="http://caizhitao.com/2015/09/22/vim-instant-markdown/"/>
    <id>http://caizhitao.com/2015/09/22/vim-instant-markdown/</id>
    <published>2015-09-22T14:40:14.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>这次和大家分享一个vim即时预览markdown的插件<a href="https://github.com/suan/vim-instant-markdown" target="_blank" rel="external">vim-instant-markdown</a><br><a id="more"></a></p>
<h1 id="前言">前言</h1><p>平时写东西的时候，大家应该很常用markdown，但是关于用什么编辑器写markdown却又是个纠结的事情，这里我们不纠结，直接和大家分享一个vim上的即时预览插件 <a href="https://github.com/suan/vim-instant-markdown" target="_blank" rel="external">vim-instant-markdown</a></p>
<h1 id="配置">配置</h1><ol>
<li>按照作者关于<a href="https://github.com/suan/vim-instant-markdown#installation" target="_blank" rel="external">插件安装说明描述</a>进行安装</li>
<li><p>如果上面的方法之后不行就请看下面的</p>
<p> vim-instant-markdown的安装相比其他插件较为特殊，它由 ruby 开发，所以你的 vim 必须集成 ruby 解释器，并且安装 <code>pygments.rb</code>、<code>redcarpet</code>、<code>instant-markdown-d</code> 三个依赖库：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 执行下面命令之前需要先翻墙</span></span><br><span class="line"></span><br><span class="line">gem install pygments.rb</span><br><span class="line">gem install redcarpet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若系统提示无 npm 命令</span></span><br><span class="line"><span class="comment"># 1. 安装npm ,如果没法用apt-get方法安装的话，参考这里http://blog.fens.me/nodejs-enviroment/</span></span><br><span class="line">sudo apt-get install npm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装intant-markdown-d</span></span><br><span class="line">npm -g install instant-markdown<span class="operator">-d</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1><ul>
<li><a href="http://my.oschina.net/fxhover/blog/382634" target="_blank" rel="external">ubuntu 升级ruby到2.1</a></li>
<li><a href="http://treelib.com/book-detail-id-48-aid-2914.html" target="_blank" rel="external">vim 即时预览markdown</a></li>
<li><a href="http://guqian110.github.io/pages/2015/02/01/learning_vim_markdown.html" target="_blank" rel="external">vim-instant-markdown具体详细配置</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次和大家分享一个vim即时预览markdown的插件<a href="https://github.com/suan/vim-instant-markdown">vim-instant-markdown</a><br>]]>
    
    </summary>
    
      <category term="vim plugs" scheme="http://caizhitao.com/tags/vim-plugs/"/>
    
      <category term="搭建个人博客" scheme="http://caizhitao.com/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="vim" scheme="http://caizhitao.com/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Android单元测试系列】二、Junit4使用]]></title>
    <link href="http://caizhitao.com/2015/07/20/android-test-use-junit4/"/>
    <id>http://caizhitao.com/2015/07/20/android-test-use-junit4/</id>
    <published>2015-07-20T13:25:01.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>在阅读本文之前，强烈建议仔细阅读上文了解Junit3的一些相关内容，那么你更需要了解Junit4。<br><a id="more"></a></p>
<h1 id="Junit3_-&gt;_Junit4">Junit3 -&gt; Junit4</h1><p>在将Junit4之前，我们需要先回顾一下Junit3的一些特性及一些评价：</p>
<ol>
<li><strong>测试类需要继承TestCase</strong>，但是java只能单继承</li>
<li><strong>测试类的测试方法需要以</strong><code>test</code><strong>方法开头，不够美观，不够优雅</strong></li>
<li><strong>初始化和回收代码在每个测试方法之前调用，一些方法其实可以统一初始化的，而无需每次测试前都初始化一遍，也即不支持类初始化</strong></li>
<li><strong>如果一个方法的测试，需要模拟很多参数的时候，可能需要写很多重复的代码，不够优雅</strong></li>
<li><strong>要写的东西总感觉有点多</strong></li>
<li>…</li>
</ol>
<p>于是，Junit4出来了，Junit4 主要使用自Java 1.5起支持的注解技术。But，Andorid SDK默认是使用Junit3的，因此，如果需要在<code>Android Studio</code>中使用Junit4，那么我们需要引入Junit4的类库才能使用，在<code>app/build.gradle</code>中添加下面依赖库：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">        <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:22.1.1'</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意是testCompile与androidTestCompile是有区别的，后面会说到</span></span><br><span class="line">        testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="@Test">@Test</h1><p>Junit3中我们测试一个方法需要继承<code>TestCase</code>并且需要测试的方法都需要固定前缀命名为<code>test</code></p>
<p>e.g</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Junit3 写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit3TestCase</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertEquals(<span class="number">2</span>, MathUtil.add(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是同样的测试用例，在Junit4中仅需要用<code>@Test</code>注解就可以完成了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Junit4 写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit4TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.assertEquals(<span class="number">2</span>, MathUtil.add(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Junit3 -&gt; Junit4测试方法使用比较:</p>
<ol>
<li>不用继承<code>TestCase</code></li>
<li>不用固定方法命名前缀一定加<code>test</code>，可以实现测试类和源码类，类名方法名完全保存一致，高雅直观</li>
<li>仅需要在被测试的方法前面加上<code>@Test</code>注解就可以将该方法标注为测试方法</li>
</ol>
<h1 id="@Before_@After">@Before @After</h1><p>Junit3中，我们重写<code>TestCase</code>的<code>setUp</code>和<code>tearDown</code>方法就可以实现每个测试方法测试前后的初始化和回收，Junit4中，仅需要在需要的方法前面加上<code>@Before</code>、<code>@After</code>即可快速实现相同的功能:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Junit3 写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit3TestCase</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUp();</span><br><span class="line">        System.out.println(<span class="string">"---Calling setUp---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.tearDown();</span><br><span class="line">        System.out.println(<span class="string">"---Calling tearDown---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---Calling test_add---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---Calling test_sub---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Junit4 写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit4TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---BeforeMethod---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---AfterMethod---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---add---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---sub---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/【Android单元测试系列】二、Junit4使用/1.png" alt=""></p>
<h1 id="@BeforeClass_@AfterClass">@BeforeClass @AfterClass</h1><p>Junit4新增了<code>@BeforeClass</code>和<code>@AfterClass</code>两个注解</p>
<ul>
<li><code>@BeforeClass</code>：在该类的所有测试方法运行之前，执行一次</li>
<li><code>@AfterClass</code>:在该类的所有测试方法运行完之后，执行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit4TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---BeforeClass---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@AfterClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---AfterClass---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---BeforeMethod---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---AfterMethod---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---add---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---sub---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/【Android单元测试系列】二、Junit4使用/2.png" alt=""></p>
<h1 id="@Ignore">@Ignore</h1><p>Junit4新增了<code>@Ignore</code>注解：被<code>@Ignore</code>注解修饰的测试方法，不会纳入测试结果中，即便错误，也不会影响到整体测试结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit4TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---add---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---sub---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="annotation">@Ignore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Assert.assertEquals(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/【Android单元测试系列】二、Junit4使用/3.png" alt=""></p>
<h1 id="异常测试">异常测试</h1><p>Junit3 中测试可能会抛出预期异常的方法时，我们需要针对这部分预期的异常进行处理，标识该异常为<strong>“正确的”</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 从一个浮点型字符串中获取小数部分的整数</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * 实际上如果是一个整数或者其他不是数字的字符串，我们除了抛出无法转型的异常之外，还可能会抛出数组越界的异常</span><br><span class="line">     * 假设是"123"，那么是没有numbers[1]的</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> str</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@throws</span> NumberFormatException</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDecimalFromString</span><span class="params">(String str)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">        String[] numbers = str.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(numbers[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Junit3 中针对预期异常的写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit3TestCase</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_getDecimalFromString</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            assertEquals(<span class="number">456</span>, MathUtil.getDecimalFromString(<span class="string">"123.456d"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            assertNotNull(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Junit4中我们仅需要在<code>@Test</code>注解中写上<code>(expected = xxxException.class)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit4TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span>(expected = NumberFormatException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDecimalFromString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.assertEquals(<span class="number">456</span>, MathUtil.getDecimalFromString(<span class="string">"123.456d"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="限时测试">限时测试</h1><p>Junit4新增限时测试，只需要在<code>@Test</code>注解中加上<code>(timeout = 1000)</code>即可标识这个方法必须在1000ms内跑完，否则测试失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sync_getOnlineConfig</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 采用线程睡眠模拟耗时操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"key1"</span>.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"value1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskJunit4TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span>(timeout = <span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync_getOnlineConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.assertEquals(<span class="string">"value1"</span>, <span class="keyword">new</span> AsyncTask().sync_getOnlineConfig(<span class="string">"key1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/【Android单元测试系列】二、Junit4使用/4.png" alt=""></p>
<h1 id="@RunWith">@RunWith</h1><p>在上文Junit3使用中，我们说到，Junit的运作模式： <strong>TestCase</strong> -&gt; <strong>TestSuite</strong> -&gt; <strong>TestRunner</strong> ==&gt; <strong>TestResult</strong>，但是上文并没有怎么讲到<code>TestRunner</code>，这是因为在Junit4中讲解比较容易理解。</p>
<h2 id="参数化测试_@Parameterized">参数化测试 @Parameterized</h2><p>回顾Junit3中的参数化测试，不断copy同一个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isStringNull</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arg.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtilJunit3TestCase</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 测试字符串是否为空的方法,因为要模拟各种边界情况，这里就详细列出各个情况</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_isStringNull</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        assertEquals(<span class="keyword">true</span>, StringUtil.isStringNull(<span class="keyword">null</span>));</span><br><span class="line">        assertEquals(<span class="keyword">true</span>, StringUtil.isStringNull(<span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">        assertEquals(<span class="keyword">true</span>, StringUtil.isStringNull(<span class="string">""</span>));</span><br><span class="line">        assertEquals(<span class="keyword">true</span>, StringUtil.isStringNull(<span class="string">""</span>, <span class="string">""</span>));</span><br><span class="line">        assertEquals(<span class="keyword">false</span>, StringUtil.isStringNull(<span class="string">"123"</span>));</span><br><span class="line">        assertEquals(<span class="keyword">true</span>, StringUtil.isStringNull(<span class="string">"123"</span>, <span class="string">""</span>));</span><br><span class="line">        assertEquals(<span class="keyword">false</span>, StringUtil.isStringNull(<span class="string">"123"</span>, <span class="string">"345"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Junit4中，我们可以通过</p>
<ul>
<li><code>@RunWith</code>:指定我们的测试环境为参数化测试(<code>Parameterized.class</code>)</li>
</ul>
<p>同时，将所有的参数列为一个数组，并修饰为<code>@Parameterized.Parameters()</code>，然后，通过<strong>自定义构造函数</strong>，为每组测试参数赋值，然后调用测试方法进行测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RunWith</span>(Parameterized.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtilJunit4TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Parameterized</span>.Parameters()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Iterable&lt;Object[]&gt; data() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][] &#123;</span><br><span class="line">                &#123;<span class="keyword">true</span>, <span class="keyword">null</span>&#125;, &#123;<span class="keyword">true</span>, <span class="keyword">new</span> String[] &#123;<span class="keyword">null</span>, <span class="keyword">null</span>&#125;&#125;, &#123;<span class="keyword">true</span>, <span class="keyword">new</span> String[] &#123;<span class="string">""</span>&#125;&#125;, &#123;<span class="keyword">true</span>, <span class="keyword">new</span> String[] &#123;<span class="string">""</span>, <span class="string">""</span>&#125;&#125;,</span><br><span class="line">                &#123;<span class="keyword">false</span>, <span class="keyword">new</span> String[] &#123;<span class="string">"123"</span>&#125;&#125;, &#123;<span class="keyword">true</span>, <span class="keyword">new</span> String[] &#123;<span class="string">"123"</span>, <span class="string">""</span>&#125;&#125;, &#123;<span class="keyword">false</span>, <span class="keyword">new</span> String[] &#123;<span class="string">"123"</span>, <span class="string">"456"</span>&#125;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mExpected;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringUtilJunit4TestCase</span><span class="params">(<span class="keyword">boolean</span> expected, String... args)</span> </span>&#123;</span><br><span class="line">        mExpected = expected;</span><br><span class="line">        mArgs = args;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isStringNull</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Assert.assertEquals(mExpected, StringUtil.isStringNull(mArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打包/套件测试_@Site-SuiteClasses">打包/套件测试 @Site.SuiteClasses</h2><p>在Junit3中，我们定义一个TestSuite，在运行时，默认是运行在TestSuite中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Junit3TestSuite</span> <span class="keyword">extends</span> <span class="title">TestSuite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">suite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestSuite suite = <span class="keyword">new</span> TestSuite(Junit3TestSuite.class);</span><br><span class="line"></span><br><span class="line">        suite.addTestSuite(MathUtilJunit3TestCase.class);</span><br><span class="line">        suite.addTestSuite(StringUtilJunit3TestCase.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> suite;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Junit4中，我们可以通过</p>
<ul>
<li><code>@RunWith</code>：指定测试环境为<code>Suite.class</code></li>
<li><code>@Site.SuiteClasses({xxx.class, xxx.class})</code>:指定待测试的类</li>
</ul>
<p>来实现同样的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RunWith</span>(Suite.class)</span><br><span class="line"><span class="annotation">@Suite</span>.SuiteClasses(&#123;MathUtilJunit4TestCase.class, StringUtilJunit4TestCase.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Junit4TestSuite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指定测试方法执行顺序_@FixMethodOrder">指定测试方法执行顺序 @FixMethodOrder</h1><p>从<strong>Junit4.11</strong>版本开始，Junit支持指定测试执行顺序，只需要在测试类添加下面3个注解之一即可:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@FixMethodOrder(MethodSorters.DEFAULT)</code></td>
<td><strong>默认值</strong>，使用一个确定的但是不可预测的排序</td>
</tr>
<tr>
<td><code>@FixMethodOrder(MethodSorters.NAME_ASCENDING)</code></td>
<td>根据测试方法的方法名排序,按照词典排序规则(ASC,从小到大,递增)。</td>
</tr>
<tr>
<td><code>@FixMethodOrder(MethodSorters.JVM)</code></td>
<td>保留测试方法的执行顺序为JVM返回的顺序。每次测试的执行顺序有可能会所不同。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">//默认值：使用一个确定的但是不可预测的排序</span></span><br><span class="line"><span class="annotation">@FixMethodOrder</span>(MethodSorters.DEFAULT)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据测试方法的方法名排序,按照词典排序规则(ASC,从小到大,递增)。</span></span><br><span class="line"><span class="comment">//@FixMethodOrder(MethodSorters.NAME_ASCENDING)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//保留测试方法的执行顺序为JVM返回的顺序。每次测试的执行顺序有可能会所不同。</span></span><br><span class="line"><span class="comment">//@FixMethodOrder(MethodSorters.JVM)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======a======"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======d======"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======c======"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======b======"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/【Android单元测试系列】二、Junit4使用/5.png" alt=""></p>
<p>实际测试，<code>MethodSorters.DEFAULT</code>和<code>MethodSorters.NAME_ASCENDING</code>基本一样的执行顺序，这里还没搞懂不同的地方，而且仅有的这3个参数其实并不能满足我们的实际需求，如果确实需要制定测试执行顺序，感觉下面两个方案可行：</p>
<ol>
<li>采用Junit4的这种指定测试执行顺序的参数，但是需要将你的测试方法名都要修改为能够按照字母由小到大排序的命名；</li>
<li>将需要按照顺序指定的测试方法集中到一个方法中执行，以模拟<strong>按指定顺序</strong>执行。</li>
</ol>
<h1 id="命令行运行测试">命令行运行测试</h1><p>通过运行 <code>./gradlew test</code> 即可运行项目的单元测试用例</p>
<h1 id="测试报告">测试报告</h1><p>Junit的单元测试报告位置默认在 <code>build/reports/tests/</code> 目录下，里面有 <code>index.html</code> 文件，打开就可以看到测试报告（通过率，失败原因等等等）</p>
<p>也可以在 <code>build.gradle</code> 文件中重新制定测试报告的位置</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">	testOptions &#123;</span><br><span class="line">		<span class="comment">// 默认测试报告路径build/reports/androidTests/</span></span><br><span class="line">		<span class="comment">// 可以通过下面代码自定义测试路径</span></span><br><span class="line">		resultsDir = <span class="string">"$&#123;project.buildDir&#125;/testReport"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1><p>在写本文的时候，我参考了很多相关的资料，但是在编写过程中，忘记了一些参考链接，或者该参考资料仅在某一点上有参考价值，因此总结下来，下面参考资料在我编写本文的时候提供了极大的帮助：</p>
<ul>
<li><strong>【强推】</strong><a href="http://www.cnblogs.com/fsjohnhuang/p/4061902.html" target="_blank" rel="external">Junit4使用详解</a></li>
<li><a href="http://www.blogjava.net/jnbzwm/archive/2010/12/15/340801.html" target="_blank" rel="external">Junit3、4相关使用</a></li>
<li><a href="http://blog.csdn.net/wangpeng047/article/details/9628449" target="_blank" rel="external">Junit4基本注解使用</a></li>
<li><a href="http://blog.csdn.net/wangpeng047/article/details/9630203" target="_blank" rel="external">Junit4参数化测试、打包测试、异常测试、限时测试</a></li>
<li><a href="http://www.cnblogs.com/nexiyi/p/junit_test_in_order.html" target="_blank" rel="external">JUnit中按照顺序执行测试方式</a></li>
<li><a href="http://blog.csdn.net/renfufei/article/details/36421087" target="_blank" rel="external">Junit指定测试执行顺序</a></li>
</ul>
<h1 id="项目源码地址">项目源码地址</h1><p>本系列的源码我都会统一放在这个项目上<a href="https://github.com/zhitaocai/UnitTest/tree/master" target="_blank" rel="external">UnitTest</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在阅读本文之前，强烈建议仔细阅读上文了解Junit3的一些相关内容，那么你更需要了解Junit4。<br>]]>
    
    </summary>
    
      <category term="Junit4" scheme="http://caizhitao.com/tags/Junit4/"/>
    
      <category term="Android Test" scheme="http://caizhitao.com/categories/Android-Test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Android单元测试系列】一、Junit3使用]]></title>
    <link href="http://caizhitao.com/2015/07/14/android-test-use-junit3/"/>
    <id>http://caizhitao.com/2015/07/14/android-test-use-junit3/</id>
    <published>2015-07-14T14:31:35.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>Android SDK 测试类是基于Junit3来进行扩展的，因此我们有必要了解Junit3，本文将详细介绍Junit3的相关知识。<br><a id="more"></a></p>
<h1 id="本文更新日志">本文更新日志</h1><h2 id="2015-07-14">2015-07-14</h2><p>第一版</p>
<h2 id="2015-07-15">2015-07-15</h2><ul>
<li><a href="#chap-assert">新增断言方法集合说明</a></li>
<li><a href="#chap-junit-async-test">新增异步方法测试</a></li>
<li><a href="#global_setUp_tearDown">新增全局初始化和全局解决方案</a></li>
<li>修改上个版本的图片贴错问题</li>
</ul>
<p><strong>本文将不再更新，后续有内容将会另起文章进行分享~~</strong></p>
<h1 id="什么是_JUnit">什么是 JUnit</h1><blockquote>
<p>JUnit 是采用测试驱动开发的方式，也就是说在开发前先写好测试代码，主要用来说明被测试的代码会被如何使用，错误处理等；然后开始写代码，并在测试代码中逐步测试这些代码，直到最后在测试代码中完全通过。</p>
<p>看了是否感觉有些不符合程序员的思维习惯（先写代码然后在调试），的确这也是JUnit 是对程序员思维习惯的“颠覆”。在这里我自己也感觉，好像很 难做到，为什么？在一匹“马”没有完全设计好前，怎么规定这匹“马”将来会如何跑？而且即使把“马”将来会如何“跑”定义好了，在实现的时候“马”被改变 了怎么办？</p>
<p>说到这里，我就说明下，我自己对 JUnit “错误”的使用方法，这也许与 JUnit 测试驱动开发的目的相矛盾，但是的确可以有效地减少 bug。JUnit 从核心来说就是将源代码与测试代码完全分开，将测试代码作为一个单独的程序。前面介绍的方法，都将源代码与 测试代码合为一体，由于源代码的重要性大于测试代码的重要性，所以测试代码经常有不完整、结构不清晰等问题，这样程序员的单元测试也就不完整。JUnit 就是被我用来做完整的单元测试，对当前的部分代码，测试其在每种“环境”下的运行结果。</p>
</blockquote>
<p>总结下来：<strong>JUnit单元测试需要在开发前写好测试代码</strong>，听起来已经够怪异了，但是经过实际使用后，发现确实需要做到这点才能真正的用好测试，另外估计你已经从这句话里面猜到究竟是谁写单元测试了，没错，就是<strong>写代码的你</strong>~~</p>
<!-- # 为什么需要单元测试 -->
<!-- 1. Android应用程序运行在各种设备上，有限的内存、CPU功率、电源、网络连接、系统版本号等等，都需要一个合理的测试覆盖率来帮助您增强和维护Android应用程序。-->
<!-- 2. 目前移动开发app生命周期短，迭代速度快，如果缺乏一个系统的测试，稍有不慎可能会因为新增了新功能而导致低版本现有的功能出现bug等等。-->
<!-- 3. **对于程序员来说：学会编写单元测试对代码设计有十分大的帮助**-->
<!-- 4. ...-->
<!-- **等等，为什么上面说的是JUnit，而这里又说Android呢？那是因为Android的测试类是基于Junit3来进行扩展编写的，因此我们有必要了解Junit3 、Junit4的相关知识。**-->
<p><a name="Junit运作模式" id="chap-junit-model"></a></p>
<h1 id="JUnit_的运作模式">JUnit 的运作模式</h1><ol>
<li><strong>定义测试代码</strong>：这也就是 JUnit 中所谓的 TestCase，根据源代码的测试需要定义每个TestCase，并将 TestCase 添加到相应的 TestSuite 方便管理。</li>
<li><strong>管理测试用例</strong>：修改了哪些代码，这些代码的修改会对哪些部分有影响，通过 JUnit 将这次的修改做个完整测试。这也就 JUnit 中所谓的 TestSuite。</li>
<li><strong>定义测试环境</strong>：在 TestCase 测试前会先调“环境”（如：参数化测试环境，套件测试环境）配置，在测试中使用，当然也可以在测试用例中直接定义测试环境。</li>
<li><strong>检测测试结果</strong>：对于每种正常、异常情况下的测试，运行结果是什么、结果是否是我们预期的等都需要有个明确的定义，JUnit 在这方面提供了强大的功能。</li>
</ol>
<p>简单来说就是： <strong>TestCase</strong> -&gt; <strong>TestSuite</strong> -&gt; <strong>TestRunner</strong> ==&gt; <strong>TestResult</strong></p>
<h1 id="如何在AndroidStudio上搭建Junit测试环境">如何在AndroidStudio上搭建Junit测试环境</h1><p>在一切的一切之前，我们需要先搭建一个Junit的运行环境，由于我们是基于Android的单元测试系列，所以我们将介绍如何在Android Studio中搭建Junit运行环境：</p>
<ol>
<li>在项目的<code>src</code>目录下依次新建文件夹<code>test</code>-&gt;<code>java</code>-&gt;<code>你的包名路径</code>，如下图（我这里的包名为<code>com.czt.saisam.unittest</code>）<br><img src="/img/【Android单元测试系列】一、Junit3使用/0.png" alt=""></li>
<li>打开<code>Build Variants</code>窗口（默认快捷键 <code>Ctrl + E</code>），修改为单元测试<code>Unit Tests</code><br><img src="/img/【Android单元测试系列】一、Junit3使用/1.png" alt=""><img src="/img/【Android单元测试系列】一、Junit3使用/2.png" alt=""></li>
<li>到这里，你可以看到你的目录结构已经有背景颜色了，表示你可以在这个目录下创建测试类了<br><img src="/img/【Android单元测试系列】一、Junit3使用/3.png" alt=""></li>
</ol>
<p>ps：如果您还不了解或者对上面步骤产生疑问，可以详细参考<a href="http://ask.android-studio.org/?/article/44" target="_blank" rel="external">这里</a></p>
<h1 id="TestCase">TestCase</h1><h2 id="编写一个简单的Junit3测试用例">编写一个简单的Junit3测试用例</h2><ol>
<li><p>在项目源码路径（<code>src/main/java/com/czt/saisam/unittest/util</code>）中创建一个简单的待测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了直观，我们一般在项目的Junit测试代码目录中，在对应于待测试类的位置中创建单元测试类（如：<code>src/main/java/com/czt/saisam/unittest/util</code>对应于<code>src/test/java/com/czt/saisam/unittest/util</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit3TestCase</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertEquals(<span class="number">2</span>, MathUtil.add(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ol>
<li>在Junit3，为了更好的管理项目，建议将测试类放在与源代码同包名下的目录下<br><img src="/img/Android单元测试详细介绍/4.png" alt=""></li>
<li>命名的话建议<code>原类名 + TestCase</code>之类的，我这里起<code>MathUtilJunit3testCase</code>是因为后面会讲到Junit4，为了区分就这样起了。</li>
<li>Junit3中规定具体运行的测试方法必须要以<code>test</code>开头，后面的自己另起。于是就有了测试方法<code>test_add()</code><em>(为了清晰,我个人习惯用下划线命名规则来命名测试方法)</em></li>
<li>测试的方法有了，那么我们根据什么来判断这个测试方法是否通过呢，没错，就是通过<code>assertEquals(期望值，实际值)</code>方法来进行断言，由于我们知道1+1肯定等于2，于是我们就断言如果方法<code>MathUtil.add(1, 1)</code>的结果肯定为2，于是就有了<code>assertEquals(2, MathUtil.add(1, 1));</code></li>
</ol>
</li>
<li><p>运行<br>右击方法就方法选择<code>Run</code>-&gt;<code>test_add</code><br><img src="/img/【Android单元测试系列】一、Junit3使用/5.png" alt=""></p>
</li>
<li><p>运行结果，因为实际值与期望值相同所以就通过了<br><img src="/img/【Android单元测试系列】一、Junit3使用/6.png" alt=""></p>
</li>
</ol>
<p><a name="assert" id="chap-assert"></a></p>
<h2 id="断言">断言</h2><p><code>TestCase</code>类是继承自<code>Assert</code>，因此默认拥有下面的断言方法，具体也可以参考源码(<code>junit.framework.Assert</code>)中支持的断言方法</p>
<table>
<thead>
<tr>
<th>断言方法</th>
<th>简单说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>assertTrue(boolean condition)</code></td>
<td>断言condiction为true</td>
</tr>
<tr>
<td><code>assertTrue(String message, boolean condition)</code></td>
<td>断言condiction为true，如果断言失败，那么就显示message的内容</td>
</tr>
<tr>
<td><code>assertFalse(boolean condition)</code></td>
<td>断言condiction为false</td>
</tr>
<tr>
<td><code>assertFalse(String message, boolean condition)</code></td>
<td>断言condiction为false，如果断言失败，那么就显示message的内容</td>
</tr>
<tr>
<td><code>fail()</code></td>
<td>断言不通过</td>
</tr>
<tr>
<td><code>fail(String message)</code></td>
<td>断言不通过，并且显示message的内容</td>
</tr>
<tr>
<td><code>assertEquals(String expected, String actual)</code></td>
<td>断言期望字符串expected的内容等于实际值字符串actual的内容</td>
</tr>
<tr>
<td><code>assertEquals(String message, String expected, String actual)</code></td>
<td>断言期望字符串expected的内容等于实际值字符串actual的内容，如果断言失败就显示message的内容</td>
</tr>
<tr>
<td><code>assertEquals(...)</code></td>
<td>基本支持各大基本数据类型的断言，这里就不一一再列了</td>
</tr>
<tr>
<td><code>assertNotNull(Object object)</code></td>
<td>断言object对象不为空</td>
</tr>
<tr>
<td><code>assertNotNull(String message, Object object)</code></td>
<td>断言object对象不为空，如果断言失败就显示message的内容</td>
</tr>
<tr>
<td><code>assertNull(Object object)</code></td>
<td>断言object对象为空</td>
</tr>
<tr>
<td><code>assertNull(String message, Object object)</code></td>
<td>断言object对象为空，如果断言失败就显示message的内容</td>
</tr>
<tr>
<td><code>assertSame(Object expected, Object actual)</code></td>
<td>断言期望对象expected等于实际对象actual</td>
</tr>
<tr>
<td><code>assertSame(String message, Object expected, Object actual)</code></td>
<td>断言期望对象expected等于实际对象actual，如果断言失败就显示message的内容</td>
</tr>
<tr>
<td><code>assertNotSame(Object expected, Object actual)</code></td>
<td>断言期望对象expected不等于实际对象actual</td>
</tr>
<tr>
<td><code>assertNotSame(String message, Object expected, Object actual)</code></td>
<td>断言期望对象expected不等于实际对象actual，如果断言失败就显示message的内容</td>
</tr>
<tr>
<td><code>failSame(String message)</code></td>
<td>暂时不明</td>
</tr>
<tr>
<td><code>failNotSame(String message, Object expected, Object actual)</code></td>
<td>暂时不明</td>
</tr>
<tr>
<td><code>failNotEquals(String message, Object expected, Object actual)</code></td>
<td>暂时不明</td>
</tr>
<tr>
<td><code>format(String message, Object expected, Object actual)</code></td>
<td>暂时不明</td>
</tr>
</tbody>
</table>
<p>PS：<br>如果需要自定义断言方法，可以自己继承<code>TestCase</code>类，新起一个如<code>DiyTestCase</code>类，在该类中自行定义断言方法，然后后续的测试用例类继承<code>DiyTestCase</code>即可采用自己的断言方法了。<br>But，Junit3提供的断言方法已经足够正常使用了，因此这里就不细讲这块。</p>
<p><a name="setUp&&tearDown" id="chap-setUp&&tearDown"></a></p>
<h2 id="setUp&amp;&amp;tearDown">setUp&amp;&amp;tearDown</h2><p>Junit3中TestCase提供了 <code>setUp</code> 和 <code>tearDown</code>方法：</p>
<ul>
<li><code>setUp()</code>:在每个测试方法之前调用，一般用于初始化</li>
<li><code>tearDown()</code>:在每个测试方法执行完毕之后调用，一般用于资源回收</li>
<li>如果类中存在多个测试方法，那么测试执行顺序为<ol>
<li><code>setUp</code>-&gt;</li>
<li><code>test_测试方法1</code>-&gt;</li>
<li><code>tearDown</code>-&gt;</li>
<li><code>setUp</code>-&gt;</li>
<li><code>test_测试方法2</code>-&gt;</li>
<li><code>tearDown</code>-&gt;</li>
<li>…</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit3TestCase</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUp();</span><br><span class="line">        System.out.println(<span class="string">"---Calling setUp---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.tearDown();</span><br><span class="line">        System.out.println(<span class="string">"---Calling tearDown---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_add</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---Calling test_add---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_sub</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---Calling test_sub---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右击类运行测试，结果如下：<br><img src="/img/【Android单元测试系列】一、Junit3使用/7.png" alt=""></p>
<h2 id="异常测试">异常测试</h2><p>测试的时候遇到异常可以通过在方法后面<code>throws Exception</code>处理，将异常抛出，在最终的测试结果中可以查看到。</p>
<p>那么什么时候需要抛出异常呢？按照普遍惯例是都抛出，下面我举一个场景：</p>
<p>实际开发过程中，我们难免会设计一些方法，这些方法可能会抛出某些指定的异常，需要给上层使用者进行处理，那么在测试的时候，我们可以将这些指定的异常进行捕捉，然后针对其他异常进行捕捉，作为测试结果，测试这些方法是否会有额外的异常出现。</p>
<p>例如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 从一个浮点型字符串中获取小数部分的整数</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * 实际上如果是一个整数或者其他不是数字的字符串，我们除了抛出无法转型的异常之外，还可能会抛出数组越界的异常</span><br><span class="line">     * 假设是"123"，那么是没有numbers[1]的</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> str</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@throws</span> NumberFormatException 交由上层调用者自己处理</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDecimalFromString</span><span class="params">(String str)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">        String[] numbers = str.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(numbers[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit3TestCase</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 这里我们捕捉测试方法可能存在的额外异常</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_getDecimalFromString</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            assertEquals(<span class="number">456</span>, MathUtil.getDecimalFromString(<span class="string">"123.456"</span>));</span><br><span class="line">            assertEquals(<span class="number">0</span>, MathUtil.getDecimalFromString(<span class="string">"abc"</span>));</span><br><span class="line">            assertEquals(<span class="number">0</span>, MathUtil.getDecimalFromString(<span class="string">"123"</span>));</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里我们捕捉这个方法会抛出的异常，因为这些都是设计的时候考虑到的，一定情况下是正常的</span></span><br><span class="line">        <span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试时就可以发现出现一个上面所说的数据越界的异常<br><img src="/img/【Android单元测试系列】一、Junit3使用/8.png" alt=""></p>
<p><strong>经过这个测试，我们就可以根据提示找到我们的源代码中设计时所忽略的问题了，那么修复就不再是问题了，是不是觉得测试开始有意思呢~~</strong></p>
<h2 id="测试单个TestCase">测试单个TestCase</h2><p>经过上面的一些说明，我们的<code>MathUtil</code>和<code>MathUtilJunit3TestCase</code>已经发生了比较多变化了，这里我再贴一下最后的代码样子（@since 2015-07-15）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 从一个浮点型字符串中获取小数部分的整数</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * 实际上如果是一个整数或者其他不是数字的字符串，我们除了抛出无法转型的异常之外，还可能会抛出数组越界的异常</span><br><span class="line">     * 假设是"123"，那么是没有numbers[1]的</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> str</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@throws</span> NumberFormatException</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDecimalFromString</span><span class="params">(String str)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">        String[] numbers = str.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(numbers[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtilJunit3TestCase</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUp();</span><br><span class="line">        System.out.println(<span class="string">"---Calling setUp---"</span>);</span><br><span class="line">        a = <span class="number">5</span>;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.tearDown();</span><br><span class="line">        System.out.println(<span class="string">"---Calling tearDown---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 测试加法——同时测试是否正确与失败</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_add</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---Calling test_add---"</span>);</span><br><span class="line"></span><br><span class="line">        assertSame(<span class="number">2</span>, MathUtil.add(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        assertNotSame(<span class="number">1</span>, MathUtil.add(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 测试减法——应该失败</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_sub</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---Calling test_sub---"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的a，b的值会在 setUp() 方法中进行初始化</span></span><br><span class="line">        assertEquals(<span class="number">3</span>, MathUtil.sub(a, b));</span><br><span class="line">        assertEquals(<span class="number">2</span>, MathUtil.sub(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_getDecimalFromString</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---Calling test_getDecimalFromString---"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            assertEquals(<span class="number">456</span>, MathUtil.getDecimalFromString(<span class="string">"123.456"</span>));</span><br><span class="line">            assertEquals(<span class="number">0</span>, MathUtil.getDecimalFromString(<span class="string">"abc"</span>));</span><br><span class="line">            assertEquals(<span class="number">0</span>, MathUtil.getDecimalFromString(<span class="string">"123"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，我们可以右击类，<code>Run</code>-&gt;<code>MathUtilJunit3TestCase</code>进行测试这个类的所有测试方法的测试，结果如下<br><img src="/img/【Android单元测试系列】一、Junit3使用/9.png" alt=""></p>
<p>可以发现这次测试有<strong>测试成功的例子(绿色图标)</strong>，也有<strong>测试失败的例子（黄色图标）</strong>，也有出现<strong>测试出现异常的例子（红色图标）</strong>，而且输出窗口也有详细写明错误地方，期望值，实际值，错误的位置等，一目了然。 </p>
<p><a name="异步方法测试" id="chap-junit-async-test"></a></p>
<h2 id="异步方法测试">异步方法测试</h2><p>实际场景下，我们很多时候会进行一些耗时操作，比如网络请求等，为了处理这些耗时操作，我们可能会根据实际情况设计出<strong>同步</strong>或者<strong>异步</strong>方法。</p>
<p>下面我们举一个比较经典——获取在线参数例子，为了方便，我这里直接采用线程睡眠来模拟耗时操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sync_getOnlineConfig</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 采用线程睡眠模拟耗时操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"key1"</span>.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"value1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">async_getOnlineConfig</span><span class="params">(String key, onFinishListener listener)</span> </span>&#123;</span><br><span class="line">        String value = sync_getOnlineConfig(key);</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onFinish(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">onFinishListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onFinish</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskJunit3TestCase</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_sync_getOnlineConfig</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">"value1"</span>, <span class="keyword">new</span> AsyncTask().sync_getOnlineConfig(<span class="string">"key1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_async_getOnlineConfig</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch signal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> AsyncTask().async_getOnlineConfig(<span class="string">"key1"</span>, <span class="keyword">new</span> AsyncTask.onFinishListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinish</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"key1"</span>.equals(key)) &#123;</span><br><span class="line">                    assertEquals(<span class="string">"value1"</span>, value);</span><br><span class="line">                &#125;</span><br><span class="line">                signal.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        signal.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在测试同步耗时方法的时候，可以像以前那样子直接断言结果值是否正确。</li>
<li>在测试异步耗时方法时，因为是异步的，所以该方法不会阻塞后面的代码逻辑，会直接跳过异步方法的回调结果，而我们的断言是在回调函数中进行的，最终结果就是导致没法执行断言。于是，我们需要在进行异步方法的运行时，采用同步加锁机制，来将这个异步操作在一定程度上变为<strong>“同步阻塞”</strong>，待回调结果时，进行解锁并断言结果的正确性。这里我们采用了 <code>CountDownLatch</code>同步辅助类来协作完成这个<strong>“同步阻塞”</strong>。</li>
</ol>
<h1 id="TestSuite">TestSuite</h1><h2 id="基本使用">基本使用</h2><p>如果你是重头看下来，那么会把焦点都关注在<code>TestCase</code>上，然后现在弹出个<code>TestSuite</code>，What’s this？ Please review <a href="#chap-junit-model">Junit运作模式</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Junit3TestSuite</span> <span class="keyword">extends</span> <span class="title">TestSuite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">suite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestSuite suite = <span class="keyword">new</span> TestSuite(Junit3TestSuite.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将测试的类加入进来</span></span><br><span class="line">        suite.addTestSuite(MathUtilJunit3TestCase.class);</span><br><span class="line">        <span class="keyword">return</span> suite;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际开发过程中，我们大多数会遵循<strong>高类聚低耦合</strong>的设计思想进行开发，那么可能就会出现多个单独的功能模块，每个功能模块的测试可以通过TestSuite来组合该功能模块所用到的测试用例。</p>
<p>那么如果在某个时刻，我们的A功能模块发生变动，仅需要重新跑一遍这个功能模块的TestSuite即可快速检验这次的变动是否通过。</p>
<p><a name="global_setUp_tearDown" id="global_setUp_tearDown"></a></p>
<h2 id="配置全局初始化和结束">配置全局初始化和结束</h2><p>TestSuite可以理解为一个功能单元集合，有时我们希望在测试这个单元功能时，全局初始化一些资源，以及全局回收一些资源（比如：初始化时建立数据库连接，结束时候统一结束连接），那么这个时候，采用TestCase的<a href="#chap-setUp&amp;&amp;tearDown"><code>setUp</code>和<code>tearDown</code></a>明显不够用了</p>
<p>Junit3提供<code>TestSetup</code>来帮助我们处理这个事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Junit3TestSuite</span> <span class="keyword">extends</span> <span class="title">TestSuite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">suite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestSuite suite = <span class="keyword">new</span> TestSuite(Junit3TestSuite.class);</span><br><span class="line"></span><br><span class="line">        suite.addTestSuite(MathUtilJunit3TestCase.class);</span><br><span class="line">        suite.addTestSuite(AsyncTaskJunit3TestCase.class);</span><br><span class="line">        suite.addTestSuite(StringUtilJunit3TestCase.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TestSetup wrapper = <span class="keyword">new</span> TestSetup(suite) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"---Calling Global_setUp---"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"---Calling Global_tearDown---"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> wrapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/img/【Android单元测试系列】一、Junit3使用/10.png" alt=""></p>
<p>PS:<br>如果你进行过实际操作的话，就会发现默认的AndroidSDK中没有<code>TestSetup</code>类，这是因为Android SDK中仅保留极少部分的Junit3代码（主要是<code>junit.framework的代码</code>），其中并没有我们所用到的<code>TestSetup</code>类<br><img src="/img/【Android单元测试系列】一、Junit3使用/11.png" alt=""></p>
<p>那么TestSetup类又是从哪里来的呢，其实在使用的时候，我已经引用了<strong>Junit4.12</strong>的类库了</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:22.1.1'</span></span><br><span class="line">    </span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个类就是在Junit4的类库中<br><img src="/img/【Android单元测试系列】一、Junit3使用/12.png" alt=""></p>
<p>看到这里你应该明白了一件事了，我们准备讲Junit4了~~</p>
<h1 id="TestRunner">TestRunner</h1><p>默认情况下是不需要自定义TestRunner的，我们将在后面的内容中讲到。</p>
<h1 id="参考资料">参考资料</h1><p>在写本文的时候，我参考了很多相关的资料，但是在编写过程中，忘记了一些参考链接，或者该参考资料仅在某一点上有参考价值，因此总结下来，下面参考资料在我编写本文的时候提供了极大的帮助：</p>
<ul>
<li><strong>【强推】</strong><a href="/pdf/Android、JUnit深入浅出.pdf">Android、JUnit深入浅出.pdf</a></li>
<li><strong>【强推】</strong><a href="http://sns.testin.cn/thread-1529-1-1.html" target="_blank" rel="external">Junit源码分析</a></li>
<li><a href="http://android.blog.51cto.com/268543/49994" target="_blank" rel="external">JUnit3的使用</a></li>
<li><a href="http://ask.android-studio.org/?/article/44" target="_blank" rel="external">Android Studio上开启Junit测试环境</a></li>
</ul>
<h1 id="项目源码地址">项目源码地址</h1><p>本系列的源码我都会统一放在这个项目上<a href="https://github.com/zhitaocai/UnitTest/tree/master" target="_blank" rel="external">UnitTest</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android SDK 测试类是基于Junit3来进行扩展的，因此我们有必要了解Junit3，本文将详细介绍Junit3的相关知识。<br>]]>
    
    </summary>
    
      <category term="Junit3" scheme="http://caizhitao.com/tags/Junit3/"/>
    
      <category term="Android Test" scheme="http://caizhitao.com/categories/Android-Test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【Android单元测试系列】前言]]></title>
    <link href="http://caizhitao.com/2015/07/14/android-test-introduce/"/>
    <id>http://caizhitao.com/2015/07/14/android-test-introduce/</id>
    <published>2015-07-14T14:27:35.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>本系列将从下面几个方面介绍Android单元测试的相关内容，下面是目前了解到的一些内容，可能会随时变动<br><a id="more"></a></p>
<h1 id="Junit">Junit</h1><p>| 面对类、对象、函数等等，在测试工程中创建一个对象出来，然后执行测试用例对该函数进行测试，但是在Android中，面对的还有组件，控件，生命周期，异步任务，消息传递等，虽然本质是SDK主动执行了一些实例的函数，但创建一个Activity并不能让它执行到resume的状态，因此需要JUnit之外的框架支持。</p>
<h2 id="Junit3">Junit3</h2><p>Android SDK 中的单元测试代码是基于Junit3扩展的，因此我们有必要学些Junit3的相关内容</p>
<h2 id="Junit4">Junit4</h2><p>Junit4 相对于 Junit3 有了很大的改进，并且采用了自Java 1.5后十分流行的注解技术，从此单元测试编写变得更加简单，而Android单元测试框架中就可以采用Junit4的注解技术了</p>
<h1 id="Android_SDK_自带框架_Instrumentation">Android SDK 自带框架 Instrumentation</h1><p>Android SDK 自带的测试类是我们重点介绍的内容，基本可以实现Android各种情况下的单元测试</p>
<h1 id="Robolectric">Robolectric</h1><p>Android 自带的测试，是需要连接模拟器或者真机才能进行测试，而Robolectric最大的特性是摆脱模拟器，直接在开发应用的过程中测试，可以简单理解为在java虚拟机上载入AndroidSdk从而实现脱机测试，极大地提高效率。</p>
<ul>
<li>可以直接运行在JVM上，无须准备Android环境，速度更快</li>
<li>可以由Jenkins周期性执行</li>
</ul>
<p>因此，Roboletric十分适用于Android的测试驱动开发</p>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="http://robolectric.org/" target="_blank" rel="external">官方文档</a></li>
<li><a href="http://segmentfault.com/a/1190000002904944" target="_blank" rel="external">介绍使用入门</a></li>
</ul>
<h2 id="Shadow">Shadow</h2><p>| Robolectric的本质是在Java运行环境下，采用Shadow的方式对Android中的组件进行模拟测试，从而实现Android单元测试。对于一些Robolectirc暂不支持的组件，可以采用自定义Shadow的方式扩展Robolectric的功能。</p>
<h1 id="Mock框架">Mock框架</h1><p>| 如果要测试的目标对象依赖关系较多，需要解除依赖关系，以免测试用例过于复杂，用Robolectric的Shadow是个办法，但是推荐更加简单的Mock框架，比如Mockito，该框架可以模拟出对象来，而且本身提供了一些验证函数执行的功能。</p>
<h1 id="Robotium">Robotium</h1><p>| Robotium 是一个基于模拟点击时间的用于进行黑河测试的Android测试开源项目：<a href="https://github.com/robotiumtech/robotium" target="_blank" rel="external">https://github.com/robotiumtech/robotium</a><br>| 官网：<a href="http://robotium.com/pages/user-guidem" target="_blank" rel="external">http://robotium.com/pages/user-guidem</a><br>| 完整API：<a href="http://robotium.googlecode.com/svn/doc/index.html" target="_blank" rel="external">http://robotium.googlecode.com/svn/doc/index.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列将从下面几个方面介绍Android单元测试的相关内容，下面是目前了解到的一些内容，可能会随时变动<br>]]>
    
    </summary>
    
      <category term="Android Test" scheme="http://caizhitao.com/categories/Android-Test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的个人博客是怎么搭建的]]></title>
    <link href="http://caizhitao.com/2015/07/04/set-up-blog-with-hexo/"/>
    <id>http://caizhitao.com/2015/07/04/set-up-blog-with-hexo/</id>
    <published>2015-07-04T13:04:12.000Z</published>
    <updated>2016-07-16T00:33:24.000Z</updated>
    <content type="html"><![CDATA[<p>关于搭建个人博客，网上已经有很多教程了，重复别人的概述显得有点浪费时间。而我在自己在搭建这个博客的时候，了解到目前大概有<a href="http://www.jintongyao.com/2014/build-a-blog-by-hexo/" target="_blank" rel="external">3种比较常用个人博客搭建方法</a>的方法，而我所用的是<strong>GitHub&amp;&amp;Hexo</strong>，因此，下面我主要总结概述一下在我搭建这个博客的时候，所用到的关于<strong>GitHub&amp;&amp;Hexo</strong>方面参考内容，大家可以参考参考，省去从海量资料中寻找有用内容的过程。</p>
<a id="more"></a>
<h1 id="重点知识">重点知识</h1><h2 id="如何搭建一个独立博客——简明Github_Pages与Hexo教程"><a href="http://cnfeat.com/2014/05/10/2014-05-11-how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></h2><ol>
<li>这是一篇十分详细的教程，先把这个过一遍有个大体的思路，然后按照文章来进行操作，不过<strong>不建议大家一开始就按照博主的描述购买域名</strong>，其实不用个人域名也可以拥有个人博客的，如果确实需要个人域名的话，建议在一切的一切之后才进行购买绑定~</li>
<li>文章中，作者也大量引用了其他参考资料，这些引文都是好东西，不要忽略</li>
</ol>
<h2 id="hexo详细介绍"><a href="http://blog.lmintlcx.com/post/blog-with-hexo.html" target="_blank" rel="external">hexo详细介绍</a></h2><p>这篇文章前面一两段话可以忽略，和上一篇推荐文章的差不多，之后的内容，作者详细的概述了各个命令，插件，目录结构的说明，十分值得收藏</p>
<h1 id="辅助参考">辅助参考</h1><h2 id="将个人域名绑定到github上"><a href="http://blog.fens.me/nodejs-enviroment/" target="_blank" rel="external">将个人域名绑定到github上</a></h2><p>如果上面的教程中，你不明白这个操作如何实现，那么可以尝试参考这篇文章，这篇在这方面讲得十分详细了</p>
<h2 id="设置多说评论模块"><a href="http://ijiaober.github.io/2014/08/06/hexo/hexo-07/" target="_blank" rel="external">设置多说评论模块</a></h2><p>这块其实是与你的所用的主题有关的，一些主题可能会直接包含一个enable的开关，写true就会开启。<br>实际上我用的是jacman的主题，仅需要在全局配置文件<code>/_config.yml</code>中写上 <code>duoshuo_shortname: your short name</code>，就可以了。</p>
<h2 id="从Hexo_2-x升级到3-x"><a href="https://github.com/hexojs/hexo/wiki/Migrating-from-2.x-to-3.0" target="_blank" rel="external">从Hexo 2.x升级到3.x</a></h2><h2 id="Hexo_主题库"><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo 主题库</a></h2><p>总有一个适合你的</p>
<h2 id="如何使用_Jacman_主题"><a href="http://wuchong.me/blog/2014/11/20/how-to-use-jacman/#" target="_blank" rel="external">如何使用 Jacman 主题</a></h2><p>作者是开发这个主题的大神，关于这个主题的用法在这篇文章中说得很具体了</p>
<h1 id="问题汇总">问题汇总</h1><h2 id="Ubuntu采用apt-get方式安装nodejs_npm失败解决方案"><a href="http://blog.fens.me/nodejs-enviroment/" target="_blank" rel="external">Ubuntu采用apt-get方式安装nodejs npm失败解决方案</a></h2><p>原因：系统提示, node和npm版本不兼容。可能是终于apt-get源没有更新造成的问题。<br>解决：手动安装,参考<a href="http://blog.fens.me/nodejs-enviroment/" target="_blank" rel="external">http://blog.fens.me/nodejs-enviroment/</a></p>
<h2 id="npm安装的时候出现_shasum_check_failed"><a href="http://www.oschina.net/question/1454207_148353" target="_blank" rel="external">npm安装的时候出现 shasum check failed</a></h2><p>原因：默认是国外的服务器，很容易出现传输过程中下载的东西受损，或者其他情况引发<br>解决：切换到国内的镜像</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> <span class="keyword">registry</span> <span class="keyword">http</span>://<span class="keyword">registry</span>.cnpmjs.org</span><br></pre></td></tr></table></figure>
<h2 id="Hexo常见问题解决方案"><a href="http://xuanwo.org/2014/08/14/hexo-usual-problem/" target="_blank" rel="external">Hexo常见问题解决方案</a></h2><p>比较多的问题总结都在这里，可以优先在浏览器中输入 <code>Ctrl + F</code> 搜索问题关键字，看看文章中是否有解决方案</p>
<h2 id="解决无法发布到github"><a href="http://blog.163.com/gis_warrior/blog/static/19361717320153100184696/" target="_blank" rel="external">解决无法发布到github</a></h2><p>错误提示：<code>ERR Deployer not found: github</code><br>原因：因为hexo 3.x(<code>hexo version</code>：查看当前hexo版本号)版本换了写法，而网上的教程很多是基于<strong>Hexo2.x</strong>进行编写的，因此基本都会遇到这个问题<br>解决方案：参考标题链接</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于搭建个人博客，网上已经有很多教程了，重复别人的概述显得有点浪费时间。而我在自己在搭建这个博客的时候，了解到目前大概有<a href="http://www.jintongyao.com/2014/build-a-blog-by-hexo/">3种比较常用个人博客搭建方法</a>的方法，而我所用的是<strong>GitHub&amp;&amp;Hexo</strong>，因此，下面我主要总结概述一下在我搭建这个博客的时候，所用到的关于<strong>GitHub&amp;&amp;Hexo</strong>方面参考内容，大家可以参考参考，省去从海量资料中寻找有用内容的过程。</p>]]>
    
    </summary>
    
      <category term="hexo" scheme="http://caizhitao.com/tags/hexo/"/>
    
      <category term="搭建个人博客" scheme="http://caizhitao.com/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>