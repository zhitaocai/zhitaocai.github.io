title: 获取当前顶端包名
tags:
  - Android 
  - Android L兼容 
categories: Android开发 
date: 2015-09-22 18:47:38
---

获取顶端包名功能在Android 5.0系统前后发生重大变化，经过各种搬运加测试后，得出一些通用解决方案
<!--more-->

# Android 5.0 之前

## 直接通过getRunningTasks方法进行获取

### 用法

```java
    ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    ComponentName cn = activityManager.getRunningTasks(1).get(0).topActivity;
    String currentPkgName = cn.getPackageName(); // 当前显示在顶端的包名
```
```xml
    <uses-permission android:name="android.permission.GET_TASKS" />
```
### 结论

1. 通过上面的方法，我们就可以获取到当前显示在顶端的包名，很多锁屏类，或者应用锁的核心就是这块
2. 可惜的是5.0(API > 20) 之后就不能再用这个方法了，**根据下面的官方说明，Android 5.0系统之后** ``getRunningTasks`` **方法被弃用了，经过实际测试之后，这个方法仅仅只能返回自身应用信息以及一些公开包名的信息(如：桌面，设置等)**
    ![](/img/获取当前顶端包名/1.png)


# Android 5.0 之后

## 通过getRunningAppProcesses方法进行获取

原理：通过获取当前在顶端运行的进程，遍历该进程下的所有包名，得出该进程下的包名列表

### 使用方法

```java
    /**
     * 检查当前在最前端运行的进程包名列表
     * @param context
     * @return 
     */
    public final static String[] getForegroundPkgName(Context context) {
        try {
            ActivityManager activityManager = (ActivityManager) context.getApplicationContext().getSystemService(
                    Context.ACTIVITY_SERVICE);
            List<ActivityManager.RunningAppProcessInfo> processInfos = activityManager.getRunningAppProcesses();
            for (ActivityManager.RunningAppProcessInfo processInfo : processInfos) {
                if (processInfo.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
                    Log.i("test", "当前顶端进程的信息");
                    Log.i("test", "进程id: " + processInfo.pid);
                    Log.i("test", "进程名  : " + processInfo.processName);
                    Log.i("test", "该进程下可能存在的包名");
                    for (String pkgName : processInfo.pkgList) {
                        Log.i("test", "  " + pkgName);
                    }
                    return processInfo.pkgList;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
```

### 结论
1. 正如原理所描述，它返回的是当前在顶端运行的进程的包名列表，正常情况下，我们开发的时候都是一个进程对应一个包名，但是如果是大公司的话，可能会将旗下所有应用共享同一个进程，于是这里就会返回一个包名数组，所以这个方法只能说满足大部分日常需求
2. 经过最近的测试，还发现了在一些新的机器上（国产为主）已经不能再使用这种方案了，因为这个方法在这些机器上，只能获取到自己应用的信息，变得和 ``getRunningTasks`` 在Android 5.0系统上的表现差不多


## 通过Android 5.0提供的新API进行获取

Android 5.0之后提供了一个新的API: ``UsageStatsManager``，通过该API我们可以准确获取到当前顶端的包名信息

### 使用方法

```java
    /**
     * 获取当前在顶端运行的应用包名(适用于Andriod 5.0以上的机器)
     * <p>
     * 通过AndroidL的新API——UsageStatsManager来进行获取，但是需要配置权限和需要用户允许获取
     * 所以需要本方法能准确获取，但是体验不太好，建议先用getRunningAppProcesses方法进行获取，不行采用这个方法
     * </p>
     * <p/>
     * 使用本方法之前需要配置下面内容
     * <pre>
     * 1. 权限配置
     *   a. 需要在AndroidManifest.xml中配置权限
     *
     *         <uses-permission
     *             android:name="android.permission.PACKAGE_USAGE_STATS"
     *             tools:ignore="ProtectedPermissions" />
     *
     *
     *   b. 然后还要在AndroidManifest.xml中的manifest标签中配置
     *         xmlns:tools="http://schemas.android.com/tools"
     *
     * 2. 需要用户允许这个应用能获取用户数据统计信息的权限
     *        Intent intent = new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);
     *        startActivity(intent);
     * </pre>
     *
     * @param time_ms 从${time_ms}内找出最近显示在顶端的包名
     * @return
     */
    public static String getTopRunningPkgNameAboveAndroidL2(Context context, long time_ms) {
     
       // 通过Android 5.0 之后提供的新api来获取最近一段时间内的应用的相关信息
       String topPackageName = null;
     
       if (Build.VERSION.SDK_INT >= 21) {
     
          try {
     
             // 根据最近time_ms毫秒内的应用统计信息进行排序获取当前顶端的包名
             long time = System.currentTimeMillis();
             UsageStatsManager usage = (UsageStatsManager) context.getSystemService("usagestats");
             List<UsageStats> usageStatsList = usage.queryUsageStats(UsageStatsManager.INTERVAL_BEST, time - time_ms, time);
             if (usageStatsList != null && usageStatsList.size() > 0) {
                SortedMap<Long, UsageStats> runningTask = new TreeMap<Long, UsageStats>();
                for (UsageStats usageStats : usageStatsList) {
                   runningTask.put(usageStats.getLastTimeUsed(), usageStats);
                }
                if (runningTask.isEmpty()) {
                   return null;
                }
                topPackageName = runningTask.get(runningTask.lastKey()).getPackageName();
                Log.i("test", "##当前顶端应用包名:" + topPackageName);
                }
             }
     
          } catch (Throwable e) {
             e.printStackTrace();
          }
       }
     
       return topPackageName;
    }
```
``` xml
    <uses-permission
        android:name="android.permission.PACKAGE_USAGE_STATS"
        tools:ignore="ProtectedPermissions" />
```

### 结论

1. 使用这个方法之前**需要用户允许应用有权查看组件使用情况**，然后才有数据返回
2. 新的API能完美进行，就是需要添加新的权限和做一下用户引导
3. 如果获取的时间设置得太短，并且这个时间内又没有发生改变的话，那么是获取不到最新的顶端的包名情况的
4. **最重要的是**，最近又发现在一些机器上（国产为主，魅族领头），是没有**允许应用有权查看使用组件的情况**的设置页面的，于是，我们大喊一声，妈蛋~~~

# 总结
目前还不能全面兼容Android 5.0系统，还需要继续寻找新的方案


# 参考资料
* http://developer.android.com/reference/android/app/ActivityManager.html#getRunningTasks(int)
* http://chaoqunz.blog.163.com/blog/static/6154877720090495819383/
* http://blog.csdn.net/qinjuning/article/details/6978560
* http://blog.csdn.net/qinjuning/article/details/7009824
* http://m.blog.csdn.net/blog/zsqxiao/44755621
* http://stackoverflow.com/questions/27689276/how-to-get-running-application-activity-name-in-android-5-0l
* http://stackoverflow.com/questions/27087675/cannot-get-foreground-activity-name-in-android-lollipop-5-0-only
* http://stackoverflow.com/questions/28361629/activitynotfoundexception-in-lollipop-when-trying-to-launch-activity-with-intent
* http://stackoverflow.com/questions/28296633/android-usage-access-for-android-5-samsung-devices
