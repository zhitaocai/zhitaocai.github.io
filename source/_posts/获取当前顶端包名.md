title: 获取当前顶端包名
tags:
  - Android 
  - Android L兼容 
categories: Android开发 
date: 2015-09-22 18:47:38
---

获取顶端包名功能在Android 5.0系统前后发生重大变化，经过各种搬运加测试后，得出一些通用解决方案
<!--more-->

# Android 5.0 之前

## 直接通过getRunningTasks方法进行获取

### 用法

需要添加下面权限:

```xml
    <uses-permission android:name="android.permission.GET_TASKS" />
```

```java
    ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    ComponentName cn = activityManager.getRunningTasks(1).get(0).topActivity;
    String currentPkgName = cn.getPackageName(); // 当前显示在顶端的包名
```
### 结论

1. 通过上面的方法，我们就可以获取到当前显示在顶端的包名，很多锁屏类，或者应用锁的核心就是这块
2. 可惜的是5.0(API > 20) 之后就不能再用这个方法了，**根据下面的官方说明，Android 5.0系统之后** ``getRunningTasks`` **方法被弃用了，经过实际测试之后，这个方法仅仅只能返回自身应用信息以及一些公开包名的信息(如：桌面，设置等)**
    ![](/img/获取当前顶端包名/1.png)


# Android 5.0 之后

## 通过getRunningAppProcesses方法进行获取

原理：通过获取当前在顶端运行的进程，遍历该进程下的所有包名，得出该进程下的包名列表

### 使用方法

```java
    /**
     * 检查当前在最前端运行的进程包名列表
     * @param context
     * @return 
     */
    public final static String[] getForegroundPkgName(Context context) {
        try {
            ActivityManager activityManager = (ActivityManager) context.getApplicationContext().getSystemService(
                    Context.ACTIVITY_SERVICE);
            List<ActivityManager.RunningAppProcessInfo> processInfos = activityManager.getRunningAppProcesses();
            for (ActivityManager.RunningAppProcessInfo processInfo : processInfos) {
                if (processInfo.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
                    Log.i("test", "当前顶端进程的信息");
                    Log.i("test", "进程id: " + processInfo.pid);
                    Log.i("test", "进程名  : " + processInfo.processName);
                    Log.i("test", "该进程下可能存在的包名");
                    for (String pkgName : processInfo.pkgList) {
                        Log.i("test", "  " + pkgName);
                    }
                    return processInfo.pkgList;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
```

### 结论
1. 正如原理所描述，它返回的是当前在顶端运行的进程的包名列表，正常情况下，我们开发的时候都是一个进程对应一个包名，但是如果是大公司的话，可能会将旗下所有应用共享同一个进程，于是这里就会返回一个包名数组，所以这个方法只能说满足大部分日常需求
2. 经过最近的测试，还发现了在一些新的机器上（国产为主，代表:小米 v5.0.2系统）已经不能再使用这种方案了，因为这个方法在这些机器上，只能获取到自己应用的信息，变得和 ``getRunningTasks`` 在Android 5.0系统上的表现差不多
3. 需要继续寻找新方案...

## 通过Android 5.0提供的新API进行获取

Android 5.0之后提供了一个新的API: ``UsageStatsManager``，通过该API我们可以准确获取到当前顶端的包名信息

### 使用方法

需要添加下面的权限:

1. 添加下面权限:

``` xml
    <uses-permission
        android:name="android.permission.PACKAGE_USAGE_STATS"
        tools:ignore="ProtectedPermissions" />
```
2. 引导用户到设置页面为自身应用开启 **有权查看使用情况的应用** 的权限:

```java
    Intent intent = new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);
    startActivity(intent);

    //一些机子上是没法直接到达上面的设置页面的，所以还需要 ``try catch`` 上面的代码，catch到错误之后尝试后备方案——进入到该设置页面的上一级页面
    
    Intent intent = new Intent(Settings.ACTION_SECURITY_SETTINGS);
    intent.setComponent(
            new ComponentName("com.android.settings", "com.android.settings.Settings$SecuritySettingsActivity"));
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    startActivity(intent);

```

3. 通过下面的代码即可获取顶端包名:

```java
    /**
     * 获取当前在顶端运行的应用包名(适用于Andriod 5.0以上的机器)
     * <p>
     * 通过AndroidL的新API——UsageStatsManager来进行获取，但是需要配置权限和需要用户允许获取
     * 所以需要本方法能准确获取，但是体验不太好，建议先用getRunningAppProcesses方法进行获取，不行采用这个方法
     * </p>
     * <p/>
     * 使用本方法之前需要配置下面内容
     * <pre>
     * 1. 权限配置
     *   a. 需要在AndroidManifest.xml中配置权限
     *
     *         <uses-permission
     *             android:name="android.permission.PACKAGE_USAGE_STATS"
     *             tools:ignore="ProtectedPermissions" />
     *
     *
     *   b. 然后还要在AndroidManifest.xml中的manifest标签中配置
     *         xmlns:tools="http://schemas.android.com/tools"
     *
     * 2. 需要用户允许这个应用能获取用户数据统计信息的权限
     *        Intent intent = new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);
     *        startActivity(intent);
     * </pre>
     *
     * @param time_ms 从${time_ms}内找出最近显示在顶端的包名
     * @return
     */
    public static String getTopRunningPkgNameAboveAndroidL2(Context context, long time_ms) {
     
       // 通过Android 5.0 之后提供的新api来获取最近一段时间内的应用的相关信息
       String topPackageName = null;
     
       if (Build.VERSION.SDK_INT >= 21) {
     
          try {
     
             // 根据最近time_ms毫秒内的应用统计信息进行排序获取当前顶端的包名
             long time = System.currentTimeMillis();
             UsageStatsManager usage = (UsageStatsManager) context.getSystemService("usagestats");
             List<UsageStats> usageStatsList = usage.queryUsageStats(UsageStatsManager.INTERVAL_BEST, time - time_ms, time);
             if (usageStatsList != null && usageStatsList.size() > 0) {
                SortedMap<Long, UsageStats> runningTask = new TreeMap<Long, UsageStats>();
                for (UsageStats usageStats : usageStatsList) {
                   runningTask.put(usageStats.getLastTimeUsed(), usageStats);
                }
                if (runningTask.isEmpty()) {
                   return null;
                }
                topPackageName = runningTask.get(runningTask.lastKey()).getPackageName();
                Log.i("test", "##当前顶端应用包名:" + topPackageName);
                }
             }
     
          } catch (Throwable e) {
             e.printStackTrace();
          }
       }
     
       return topPackageName;
    }
```

*如果希望能检测用户是否已经允许本应用有权查看组件使用情况，可以通过下面代码进行检查:*

```java
    if (Build.VERSION.SDK_INT >= 19) {
        PackageManager packageManager = context.getPackageManager();
        ApplicationInfo applicationInfo = packageManager.getApplicationInfo(context.getPackageName(), 0);
        AppOpsManager appOpsManager = (AppOpsManager) context.getSystemService(Context.APP_OPS_SERVICE);
        int mode = appOpsManager
                .checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS, applicationInfo.uid, applicationInfo.packageName);
        return mode == AppOpsManager.MODE_ALLOWED;
    }
```


### 结论

1. 使用这个方法之前**需要用户允许应用有权查看组件使用情况**，然后才有数据返回
2. 新的API能完美进行，就是需要添加新的权限和做一下用户引导
3. 如果获取的时间设置得太短，并且这个时间内又没有发生改变的话，那么是获取不到最新的顶端的包名情况的
4. **最重要的是**，最近又发现在一些机器上（国产为主，魅族领头，LG G3在列），是没有**允许应用有权查看使用组件的情况**的设置页面的，于是，我们大喊一声，妈蛋~
5. 需要继续寻找新方案...

# 总结(截止至2015-09-22)

目前还不能全面兼容Android 5.0系统，还需要继续寻找新的方案


# 后续尝试

## 尝试dunpsys命令

如果是在adb shell中使用 ``dumpsys activity activities`` 的话，倒是可以获取到顶端的包名，但是代码中的话，除非你拥有和系统应用的签名，否则，是不能使用 ``android.permission.DUMP`` 权限的，也就不能使用 ``dumpsys`` 命令了

**continue...**

## 尝试通过/proc目录进行判断

``/proc`` 目录是存放当前系统运行中的一些信息，包括各个进程，cpu，内存，启动时长等，具体目录介绍可以参照[这里](http://blog.chinaunix.net/uid-23960192-id-3549140.html)，偶然间发现了[stackoverflow](http://stackoverflow.com/questions/30619349/android-5-1-1-and-above-getrunningappprocesses-returns-my-application-packag) 上的这个神贴，就是用这个方法的，无须任何权限，但是作者也说到缺乏测试，而我这边自己测试之后发现不是很理想，很多机子都不行

**continue...**

## 通过accessibility-service服务进行

方法参考[这里](http://stackoverflow.com/questions/3873659/android-how-can-i-get-the-current-foreground-activity-from-a-service/27642535#27642535)，经过测试，能够不用在配置新权限的前提下完美运行，但是也有一些问题

> 1. Each user must enable the service via Android's accessibility settings in order for the AccessibilityEvents to be received.
The service generally runs until the user explicitly disables it. You can make the service stop itself if needed, but I don't know of any way to programmatically restart it correctly if you've stopped it.
2. When a user tries to enables the AccessibilityService, they can't press the OK button if an app has placed an overlay on the screen. Some apps that do this are Velis Auto Brightness and Lux. This can be confusing because the user might not know why they can't press the button or how to work around it.
3. The AccessibilityService won't know the current activity until the first change of activity.

**continue...**

# 参考资料
* http://developer.android.com/reference/android/app/ActivityManager.html#getRunningTasks(int)
* http://chaoqunz.blog.163.com/blog/static/6154877720090495819383/
* http://blog.csdn.net/qinjuning/article/details/6978560
* http://blog.csdn.net/qinjuning/article/details/7009824
* http://m.blog.csdn.net/blog/zsqxiao/44755621
* http://stackoverflow.com/questions/27689276/how-to-get-running-application-activity-name-in-android-5-0l
* http://stackoverflow.com/questions/27087675/cannot-get-foreground-activity-name-in-android-lollipop-5-0-only
* http://stackoverflow.com/questions/28361629/activitynotfoundexception-in-lollipop-when-trying-to-launch-activity-with-intent
* http://stackoverflow.com/questions/28296633/android-usage-access-for-android-5-samsung-devices
* http://android.stackexchange.com/questions/114525/how-to-access-apps-with-usage-access-setting-on-lg-g3
* http://blog.chinaunix.net/uid-23960192-id-3549140.html
* http://stackoverflow.com/questions/30619349/android-5-1-1-and-above-getrunningappprocesses-returns-my-application-packag
* http://stackoverflow.com/questions/3873659/android-how-can-i-get-the-current-foreground-activity-from-a-service/27642535#27642535
